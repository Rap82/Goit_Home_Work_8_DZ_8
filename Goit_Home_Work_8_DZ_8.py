# ===================  Home work 8 ========================

# =================   Можливості деяких вбудованих пакетів Python =================

# =================== Робота з датою і часом (datetime)  ==========================

# Робота з датою і часом у Python реалізована у пакеті datetime. Основні можливості datetime:



# визначення поточної дати і часу;
# обчислення інтервалу між двома подіями;
# визначення дня тижня, високосного року для будь-якої дати у минулому не раніше року datetime.MINYEAR
# або в майбутньому не пізніше року datetime.MAXYEAR;
# порівняння дати і часу декількох подій за допомогою операторів порівняння;
# робота з часовими зонами, порівняння подій з урахуванням часових зон та переходу на літній/зимовий час;
# перетворення дати/часу в рядок і навпаки.
# Щоб отримати поточну дату і час без урахування часового пояса, можна викликати метод now() у datetime:



# from datetime import datetime

# current_datetime = datetime.now()
# print(current_datetime) # 2020-10-09 22:13:35.053819


# У результаті виклику now() ми отримуємо об'єкт datetime, у якого є ряд корисних атрибутів:



# from datetime import datetime

# current_datetime = datetime.now()

# print(current_datetime.year)        # 2020
# print(current_datetime.month)       # 10
# print(current_datetime.day)         # 09
# print(current_datetime.hour)        # 22
# print(current_datetime.minute)      # 32
# print(current_datetime.second)      # 22
# print(current_datetime.microsecond) # 819366


# В об'єкта datetime є методи, щоб отримати дату (без часу) та час (без дати):



# from datetime import datetime

# current_datetime = datetime.now()
# print(current_datetime.date())  # 2020-10-09
# print(current_datetime.time())  # 22:13:35.053819


# Щоб створити об'єкт datetime з будь-якою вибраною датою, можна зробити так:



# from datetime import datetime

# d1 = datetime(year=2012, month=1, day=7, hour=14)
# print(d1) # 2012-01-07 14:00:00


# Щоб дізнатися день тижня, можна скористатися методом weekday:



# from datetime import datetime

# seventh_day_2020 = datetime(year=2020, month=1, day=7, hour=14)
# print(seventh_day_2020.weekday())   # 1


# Дні тижня у Python починаються з понеділка і він буде 0. У прикладі вище 7 Січня 2020 року було вівторком.



# Щоб порівняти два об'єкти datetime, достатньо скористатися оператором порівняння:



# from datetime import datetime

# current_datetime = datetime.now()

# future_month = (current_datetime.month % 12) + 1
# future_year = current_datetime.year + int(current_datetime.month / 12)
# future_datetime = datetime(future_year, future_month, 1)

# print(current_datetime < future_datetime)    # True


# ================================ Звдання 1 / Task 1 ======================================

# ++++++++   Робота з датою і часом у Python реалізована у пакеті datetime +++++++++++++++

# Основні можливості datetime:

# визначення поточної дати і часу;
# обчислення інтервалу між двома подіями;
# визначення дня тижня, високосного року для будь-якої дати у минулому не раніше року datetime.MINYEAR 
# або майбутньому не пізніше року datetime.MAXYEAR;
# порівняння дати і часу декількох подій за допомогою операторів порівняння;
# робота з часовими зонами, порівняння подій з урахуванням часових зон та переходу на літній/зимовий час;
# перетворення дати/часу в рядок і навпаки.
# DATETIME
# Щоб отримати поточну дату і час без урахування часового пояса, можна викликати метод now() у datetime:

# from datetime import datetime

# current_datetime = datetime.now()
# print(current_datetime) # 2020-10-09 22:13:35.053819
# У результаті виклику now() ми отримуємо об'єкт datetime, у якого є ряд корисних атрибутів:

# from datetime import datetime

# current_datetime = datetime.now()

# print(current_datetime.year)        # 2020
# print(current_datetime.month)       # 10
# print(current_datetime.day)         # 09
# print(current_datetime.hour)        # 22
# print(current_datetime.minute)      # 32
# print(current_datetime.second)      # 22
# print(current_datetime.microsecond) # 819366
# У об'єкту datetime є методи, щоб отримати дату (без часу) та час (без дати):

# from datetime import datetime

# current_datetime = datetime.now()
# print(current_datetime.date())  # 2020-10-09
# print(current_datetime.time())  # 22:13:35.053819
# Щоб створити об'єкт datetime з будь-якою вибраною датою, можна зробити так:

# from datetime import datetime

# d1 = datetime(year=2012, month=1, day=7, hour=14)
# print(d1) # 2012-01-07 14:00:00
# Щоб дізнатися день тижня, можна скористатися методом weekday:

# from datetime import datetime

# seventh_day_2020 = datetime(year=2020, month=1, day=7, hour=14)
# print(seventh_day_2020.weekday())   # 1
# Дні тижня у Python починаються з понеділка і він буде 0. У прикладі вище 7 Січня 2020 року було вівторком.

# Щоб порівняти два об'єкти datetime, досить скористатися оператором порівняння.

# TIMEDELTA
# Якщо відняти від одного datetime об'єкту інший, то отримаємо timedelta об'єкт. Він відповідає за відрізок часу між двома датами.

# from datetime import datetime

# seventh_day_2019 = datetime(year=2019, month=1, day=7, hour=14)
# seventh_day_2020 = datetime(year=2020, month=1, day=7, hour=14)

# difference = seventh_day_2020 - seventh_day_2019
# print(difference)                   # 365 days, 0:00:00
# print(difference.total_seconds())   # 31536000.0
# Об'єкти timedelta можна створювати самостійно щоб отримати дату/час віддалену від початкової:

# from datetime import datetime, timedelta

# seventh_day_2020 = datetime(year=2020, month=1, day=7, hour=14)
# four_weeks_interval = timedelta(weeks=4)

# print(seventh_day_2020 + four_weeks_interval)   # 2020-02-04 14:00:00
# print(seventh_day_2020 - four_weeks_interval)   # 2019-12-10 14:00:00
# Об'єкт timedelta можна створити, задаючи тижні, дні, години, хвилини, секунди, мілісекунди і мікросекунди:

# from datetime import timedelta
# delta = timedelta(
#     days=50,
#     seconds=27,
#     microseconds=10,
#     milliseconds=29000,
#     minutes=5,
#     hours=8,
#     weeks=2
# )
# Якщо якийсь параметр не заданий, то він дорівнює 0 за умовчанням.

# Робота з часовими поясами припускає знання класів у Python і ми розглянемо її пізніше.

# TIMESTAMP
# Окремо треба сказати про timestamp. timestamp — це кількість секунд, що пройшло з 00 годин 00 хвилин 1 Січня 1970 року 
# у UTC (часовий пояс Грінвіча). Це просто прийнята константа і нічого особливого вона не означає. 
# Просто для зручності колись почали відлічувати час в секундах з цієї миті і це виявилося дуже зручно. 
# Адже порівняти два числа завжди легше і швидше, чим порівняти складну структуру дат і часів.

# Звичайно можна з timestamp отримати дату/час і навпаки:

# from datetime import datetime

# seventh_day_2020 = datetime(year=2020, month=1, day=7, hour=14)
# ts = seventh_day_2020.timestamp()
# print(ts)   # 1578398400.0

# ts += 100_000
# print(datetime.fromtimestamp(ts))   # 2020-01-08 17:46:40

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Розробіть функцію get_days_from_today(date), яка повертатиме кількість днів від поточної дати,
# де параметр date - це рядок формату '2020-10-09' (рік-місяць-день).

# Підказки:

# Параметр date розбити на рік, місяць та день можна використовуючи метод рядків split.
# datetime приймає аргументи типу int, використовуйте перетворення типів.
# ігноруйте години, хвилини та секунди для вашої дати, важливі повні дні.
# кількість днів ви можете отримати відніманням з поточної дати, заданої в змінній date (без часу).
# Наприклад: Якщо поточна дата - '5 травня 2021', то виклик get_days_from_today("2021-10-09") поверне нам -157.


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from datetime import datetime  # З бібліотеки *datetime  імпортуємо функцію *datetime . Бібліотека для роботи з датою і часом.


# def get_days_from_today ( date ) : # Функція яка приймає оди аргумент . *date (тип *str ) формату 'Рік-Місяць-День' # '2024-10-09'
#                                    # Повертає ціле число днів (тип *int) від поточної дати до вказаної в *date .
#                                    # якщо *date -містить майбутню дату (та яка має настати від поточної) То повертає відємне число днів.
#                                    # якщо *date -містить минулу дату (та яка вже відбулась  від поточної) То повертає додатнє число днів

#     list_some_date = date.split ('-')  # Передану у функцію дату *date типу рядок . Розділяємо методом *.split ('-') - по знаку тире "-"
#                                        # отримаємо у *list_some_date список із 3 елементів ,для ашого тестового значення - *['2024', '10', '09']. 
#                                        #  Де перший елемент списку '2024'- це рік, Другий - '10' -місяць, Третій '09' - день 

#     some_date =  datetime ( year = int ( list_some_date [0] ), month = int ( list_some_date [1] ), day = int ( list_some_date [2] ) ) # 
#                         # За допомогою вбудованої функції *datetime ( year = *int , month = *int, day = *int ) в зміну *some_date передаєм обєкт типу *datetime 
#                         #  В *year передаєм перший елемент з списку *list_some_date приведений до типу *int .  *int ( list_some_date [0] ) = 2024
#                         #  В *month передаєм другий елемент з списку *list_some_date приведений до типу *int .  *int ( list_some_date [1] ) = 10
#                         #  В *day передаєм третій  елемент з списку *list_some_date приведений до типу *int . *int ( list_some_date [2] ) = 09
#                         # Функція *datetime - містить ще інші парметри зокрема години , хв , секунди , мікросекунди . Але для нашого завдання ці дані непотрібні.
#                         # Всі параметри які не передані у фцнкцію замінняються 00 - нулями .
#                         # Тому для нашого випадку *some_date = 2024-10-09 00:00:00
    
#     # print ( list_some_date)
#     # print ( some_date )

#     data_now = datetime.now() # Предаєм у зміну *data_now поточне значення дати і часу за допомогою вбудованої функції *datetime і методу *.now() . 
#                               # Для нашого тестового значення 2023-12-30 07:34:52.039276 ( точний час на момент запуску коду)

#     # print (data_now )

#     data_diferent_curent = data_now.date() - some_date.date() # Порівнюємо два обєкти *datetime віднімаючи їх і результат передаємо в *data_diferent_curent
#                                                               # *data_diferent_curent = -284 days, 0:00:00
#     print ( data_diferent_curent)


#     return  data_diferent_curent.days  # повертаємо з нашої функції значення *data_diferent_curent - приведеного до форми *.days . 
#                                        # Метод *.days застосований до обєкта *datetime повертає з обєкта ціле число днів. 
#                                        # Якщо дата з майбутнього то відємне число. В нашому прикладі вказано майбутню дату ому поверне 
#                                        # -284

   


# date = '2024-10-09'  #  Тестове значення


# print ( get_days_from_today ( date ) )  # Принтимо результат роботи нашої функції  * get_days_from_today ( date ) = -284


# ================================ Звдання 2 / Task 2 ======================================

#   КІЛЬКІСТЬ ДНІВ НА МІСЯЦЬ

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Напишіть функцію визначення кількості днів у конкретному місяці. Ваша функція повинна приймати два параметри: 
# month - номер місяця у вигляді цілого числа в діапазоні від 1 до 12 і year - рік, що складається із чотирьох цифр. 
# Перевірте, чи функція коректно обробляє місяць лютий високосного року.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from datetime import date  #  З бібліотеки *datetime  імпортуємо функцію *datetime  . Бібліотека для роботи з датою і часом.

# DAYS_in_MONTH = { '1': 31, '2': 28, '3': 31, '4': 30, '5': 31, '6': 30, '7': 31, '8': 31, '9': 30, '10': 31, '11': 30, '12': 31
   
#                     }  # Словник який містить ключами місяці а значеннями кількість днів в цьому місяці . Для невисокосних років.

# DAYS_in_MONTH_VYSOKOS = { '1': 31, '2': 29, '3': 31, '4': 30, '5': 31, '6': 30, '7': 31, '8': 31, '9': 30, '10': 31, '11': 30, '12': 31
   
#                             }  # Словник який містить ключами місяці а значеннями кількість днів в цьому місяці . Для високосних років.

# def vysokosnyj_year ( year ) : # Допоміжна функція . яка визначає чи перданий в функцію рік високосний.
#                                # Приймає один аргумент . Ціле число . Повертає *True -якщо високосний і *False якщо ні.
    
#     if  ( ( year % 4 == 0 ) and ( year % 100 != 0 ) or ( year % 400 == 0 ) ) : #Високочний рік повинен бути кратним 4 і не кратним 100 або кратним 400 .
       
#        vysokosnyj_year  = True  # Якщо виконалась умова *if ... Значить рік високосний присвоюємо в *vysokosnyj_year = *True

#     else:
      
#       vysokosnyj_year  = False  #  Якщо не виконалась умова *if ... Значить рік не високосний присвоюємо в *vysokosnyj_year = *False
    
#     return vysokosnyj_year  #  Повертаємо значення присвоюємо в *vysokosnyj_year . 


# def get_days_in_month ( month, year ) :  # Основна фінкція . В ній перевіряємо чи переданий рік в *year високисний чи ні за допомогою функції *vysokosnyj_year ( year )
#                                          #  Далі якщо високосний то повертаємо відповідне значення днів за ключем *month  з нашого словника *DAYS_in_MONTH_VYSOKOS
#                                          #  якщо не високосний то повертаємо відповідне значення днів за ключем *month  з нашого словника *DAYS_in_MONTH
    
#     month = str ( month )  #  Приводимо наш month до типу *str і переприсовоюємо це значення в *month

     
#     if vysokosnyj_year ( year ) :  #  перевіряємо повернутий результат з функції *vysokosnyj_year ( year ) якщо високосний поверне *True
                                   

#         days_in_month = DAYS_in_MONTH_VYSOKOS.get ( month )  # Якщо виконалась умова *if... То повертаємо відповідне значення для ключа * month з нашого словника *DAYS_in_MONTH_VYSOKOS 
#                                                             #  для тестових значень *year = 2020 і *month = 2  Поверне -  29

        
     
#         return days_in_month   # Повертаємо з функції значення *days_in_month
    
#     else :
       
#        days_in_month = DAYS_in_MONTH.get ( month )  # # Якщо не виконалась умова *if... То повертаємо відповідне значення для ключа * month  з нашого словника *DAYS_in_MONTH
#                                                     #  для тестових значень *year = 2020 і *month = 2  Поверне -  28
       
#        return days_in_month    #
       

# month = 2  #  Тестове значення місяць Лютий . Для високосного року 29 днів 

# year = 2020  # Тестове значення високосний рік . 

# month = 2  # Тестове значення місяць Лютий . Для звичного  року 28 днів 

# year = 2021  # Не вискосний рік

# print ( get_days_in_month ( month, year ) )   # Прінтимо значення повернуті в результаті виконання нашої фцнкції *get_days_in_month ( month, year )
#                                             #  Для звчайного року Лютий ( 2 місяць року) видасть 28 .
#                                             #  Для високосного року Лютий ( 2 місяць року) видасть 29 .



# ================================ Звдання 3 / Task 3 ======================================

#  ++++++++++++++++++++ Перетворення дати  в інший формат  Метод *імя_обєкта_datatime*.strftime ( '%A %d %B %Y' ) ++++++++++++++

# ++++++++++++++++++++++++++++++++++++  Короткий опис методу *імя_обєкта_datatime*.strftime ( '%A %d %B %Y' ) , всі можливі формати шукай в інтернету +++++++

# date.strftime ( '%A %d %B %Y' ) # Формуємо потрібний нам формат дати за допомогою методу *date.strftime ( '%A %d %B %Y' ) . в нашому випадку = *Thursday 27 May 2021

                                    # меод *date.strftime ( '%A %d %B %Y' ) повертає з зміної *date ,яка містить обєкт *datatime ,- рядок вказаного формату 
                                    # де *date - імя_яке_містить_обєкт_datetime ,
                                    #  *( '%A %d %B %Y' ) - формат який треба повернут. 
                                    #  В нашому *( ' %A %d %B %Y ' ) ='Thursday 27 May 2021'
                                    # параметер  *%A - це конкретний день тижня (з понеділка по неділю (англійською) включно , на який вказує задане число , місяць і рік ) в нашому випадку *Thursday . 
                                    # параметер  *%a - виводить те саме що й *%A тільки в короткому записі . для нашого випадку *%a = Thu . в нашому завданні не застосовуємо.
                                    # параметер *%d - це конкретне число з календаря . В нашому випадку *%d = 27 
                                    # параметер *%m  - це цифровий запис конкретного місяця з обєкту *datatime . *%m = 05 (в нашому випадку не застосовуємо)
                                    # параметер *%B - це словесне значення конкретного місяця (з січння по грудень (англійською) на який вказує цифоровий запис з *month з обєкту *datatime ) в нашому випадку month = 05 отже *%B = May
                                    # параметр  *%Y - це рік з обєкту  *datetime

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


# Коли треба перетворити дату/час в рядок, ви можете скористатися функцією str, яка перетворить datetime у рядок. 
# Але часто формат такого перетворення незручний і в Python є окрема міні-мова для опису, як перетворити дату/час в рядок:

# from datetime import datetime

# seventh_day_2020 = datetime(year=2020, month=1, day=7, hour=14)
# print(seventh_day_2020.strftime('%A %d %B %Y')) # Tuesday 07 January 2020
# Та ж міні-мова використовується для конвертації вже рядків в дату/час:

# from datetime import datetime

# s = '10 January 2020'
# print(datetime.strptime(s, '%d %B %Y')) # 2020-01-10 00:00:00
# Деталі можна вивчити на сторінці офіційної документації.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Напишіть функцію get_str_date(date), яка перетворюватиме дату з бази даних у форматі ISO '2021-05-27 17:08:34.149Z' 
# у вигляді наступного рядка 'Thursday 27 May 2021' - день тижня, число, місяць та рік. 
# Перетворене значення функція повертає під час виклику.


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from datetime import datetime 


# def format_date_year_month_day ( date ) : # Допоміжна функція яка отримує один аргумент в вигляді рядка формату '2021-05-27 17:08:34.149Z' Де дата від часу відділяється одним пробілом.
#                                           # і повртає список із 3 елементів . Пеший рік , другий місяць , третій день. Для нашого тестового значення
#                                           #   '2021-05-27 17:08:34.149Z' поверне ['2021', '05', '27']

#     date_without_time = date.split ( " " )[0] # за добпомогою методу . *.split( " " ) розбиваэмо наш рядок *date за пробілом . Метод *.split- поверне  в память нам список із двох елементів в нашому випадку для *'2021-05-27 17:08:34.149Z'
#                                              #  буде ['2021-05-27', '17:08:34.149Z'] і відразу беремо 1 елемент з того списку *[0]-вказує на 1 елемент з списку- і присвоюємо в зміну *date_without_time
#                                             #  Тобто такий запис *date.split( " " )[0] присвоїть в нашу зміну *date_without_time = '2021-05-27' для нашого тестового значення.
#     # print ( date_without_time )
#     list_date_without_time = date_without_time.split ( '-' ) # Отриманий рядок в *date_without_time розбиваємо ще раз методом .split() але вже по сиволу тире "-"
#                                                             #   Отримаємо список з 3 елементів для нашого тестового значення , його і присвоюємо в зміну *list_date_without_time
                                                            

#     return list_date_without_time   # Повертаємо наш список з функції *list_date_without_time = ['2021', '05', '27'] для *date'2021-05-27 17:08:34.149Z'

# def get_str_date ( date ) : # Основна функція яка отримує один аргумент типу рядок наступного формату  *'2021-05-27 17:08:34.149Z' 
#                             #  і повертає рядок вже зміненого формату  *'Thursday 27 May 2021'
    
#     list_date_without_time = format_date_year_month_day ( date ) # За допомогою нашої допоміжної функції *format_date_year_month_day ( date ) повертаємо в  *list_date_without_time список із 3 елемнтів формату рік, місяць і день з вказного рядка в *date
#                                                                 #  *list_date_without_time = ['2021', '05', '27']
#     # print (list_date_without_time)

#     date = datetime ( year = int ( list_date_without_time[0] ), month = int ( list_date_without_time[1] ) ,  day = int ( list_date_without_time[2]) ) # переприсвоюємо  в *date обєкт datetime ( year = *int , month = *int, day = *int) з відповідними значеннями з списку *list_date_without_time
#                                     # Для нашого тестового завдання *date = 2021-05-27 00:00:00 де час буде заповнено 0 оскільки ми його не передавали в вбудовану  функцію *datetime()
#     # print ( date )
#     str_date = date.strftime ( '%A %d %B %Y' ) # Формуємо потрібний нам формат дати за допомогою методу *date.strftime ( '%A %d %B %Y' ) і присвоюємо в *str_date
#                                     # меод *date.strftime ( '%A %d %B %Y' ) повертає з зміної *date ,яка містить обєкт *datatime ,- рядок вказаного формату 
#                                     # де *date - імя_яке_містить_обєкт_datetime , *( '%A %d %B %Y' ) - формат який треба повернут. 
#                                     #  В нашому *( ' %A %d %B %Y ' ) ='Thursday 27 May 2021'
#                                     # параметер  *%A - це конкретний день тижня (з понеділка по неділю (англійською) включно , на який вказує задане число , місяць і рік ) в нашому випадку *Thursday . 
#                                     # параметер  *%a - виводить те саме що й *%A тільки в короткому записі . для нашого випадку *%a = Thu . в нашому завданні незастосовуємо.
#                                     # параметер *%d - це конкретне число . В нашому випадку *%d = 27 ( *%m (05) - це цифровий запис конкретного місяця з обєкту *datatime - в нашому випадку не застосовуємо)
#                                     # параметер *%B - це словесне значення конкретного місяця (з січння по грудень (англійською) на який вказує цифоровий запис з *month з обєкту *datatime ) в нашому випадку month = 05 отже *%B = May
#                                     # параметр  *%Y - це рік з обєкту  *datetime
                                    
#     # print ( date )
#     return str_date  # Повертаємо з функції потрібний результа вказаного формату в завданні. *str_date = 'Thursday 27 May 2021'

    

# date = '2021-05-27 17:08:34.149Z' # Тестове значення .

# print ( get_str_date ( date ) )  # Принтимо повернутий рядок потрібного формату - *Thursday 27 May 2021



# ================================ Звдання 4 / Task 4 ======================================

#  ++++++++++++++++++++ Для генерації випадкових (псевдовипадкових) чисел у Python є пакет random. ++++++++++++++

#     ++++++++++  короткий опис пакету і методів random   ++++++++++++++++++++

# Для генерації випадкових (псевдовипадкових) чисел у Python є пакет random. 
# Він досить хороший для ряду побутових завдань, але не для криптографії. 
# На жаль вбудований генератор псевдовипадкових чисел досить скоро починає повторюватися і не є досить криптостійким. 
# Проте, для прикладних завдань поза сферою криптографії його цілком вистачає.

# Отримання випадкового цілого числа з рівномірного розподілу в інтервалі між 1 та 1000 включно:

# import random

# random.randint(1, 1000)
# Якщо треба отримати випадкове число в інтервалі 0, 1 включно:

# import random

# random.random()
# Коли у вас є список об'єктів і вам потрібно перемішати порядок елементів в цьому списку на випадковий:

# import random

# fruits = ['apple', 'banana', 'orange']
# random.shuffle(fruits)
# print(fruits)   # ['banana', 'orange', 'apple']
# Якщо потрібно вибрати випадковий елемент зі списку:

# import random

# fruits = ['apple', 'banana', 'orange']
# print(random.choice(fruits))   # 'banana'
# Щоб вибрати N випадкових елементів зі списку:

# import random

# fruits = ['apple', 'banana', 'orange']
# print(random.choices(fruits, k=4))   # ['banana', 'orange', 'orange', 'orange']
# Щоб вибрати N елементів, що не повторюються, зі списку:

# import random

# fruits = ['apple', 'banana', 'orange']
# print(random.sample(fruits, k=2))   # ['banana', 'orange']
# Зверніть увагу, що k не може бути більше довжини fruits.

# Якщо вам треба скористатися відмінним від рівномірного розподілу, можете вибрати один із підтримуваних розподілів.

# Щоб випадково вибрати число із послідовності:

# import random

# print(random.randrange(1, 11))
# Функція random.randrange поверне довільне число від 1 до 10 включно. Зазначене під час виклику число 11 не з'явиться при виклику функції.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Щоб виграти головний приз лотереї, необхідний збіг кількох номерів на лотерейному квитку з числами, 
# що випали випадковим чином і в певному діапазоні під час чергового тиражу. Наприклад,
# необхідно вгадати шість чисел від 1 до 49 чи п'ять чисел від 1 до 36 тощо.

# Напишіть функцію, яка випадково підбиратиме набір чисел для лотерейного квитка. Серед цих чисел не має бути дублікатів.

# Формат функції get_numbers_ticket(min, max, quantity), де параметри:

# min - мінімальне значення діапазону, не може бути менше 1
# max - максимальне значення діапазону, не може бути більше 1000
# quantity - кількість чисел у наборі (має бути min < quantity < max)
# Функція повинна повернути перелік випадкових чисел за зростанням. Якщо порушено умови обмежень на параметри функції, 
# тоді повернути пустий список.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# import random # Імпортуємо бібліотеку randomn для роботи з її функціями і методами. Бібліотека генерування випадковостей.

# from random import randrange # З бібліотеки  random імпортуємо метод *randrange (*діапазон) генерує випадкове число з вказаного діапазону.
#                             #   *random.randrange ( min, max ) де *random - вбудований модуль, *.randrange - метод генерації випадкового значення з вказаного діапазону.
#                             #  min - мінімаьне можливе значення , max - максимально можливе значення . min і max - значення  включно .

# def get_numbers_ticket ( min, max, quantity ) :  # Функція приймає 3 параметри типу *int . Повертає список який містить *quantity елементів , відсортованих в порядку зростання ,  згенерованих випадковим чином  з вказаного діапазону *min і *max
#                                                  # якщо *min,  *max і *quantity не відповідають вимогам умови завдання повертає пустий список *[] .
    

#     random_list = []  #  *random_list - список в який будемо записувати наші згенеровані значення і повертати з функції . Початкове значення пустий список *[] .
   

#     if min > 0  and max <= 1000 and max > quantity :  # Умова для перевірки вхідних значень.  
#                                                       # *min - мінімальне значення діапазону, не може бути менше , *min > 0 
#                                                       # *max - максимальне значення діапазону, не може бути більше 1000 , *max <= 1000
#                                                       #  Максимальне значення діапазону має бути більше кількості чисел які потрібно згенерувати. *max > *quantity  

#         while True :   # Генерувати наш список випадкових чисел будемо в циклі *while . 
#                        # Як тільки отримаємо потрібну кількість значень перериваємо цикл оператором *break

#             random_num = random.randrange ( min, max )  # в зміну *random_num присвоюємо , випадковим чином згенероване ,  значення з діапазону ( min, max ) за допомгою вбудованої фінкці *random і методу *.randrange ( min, max )
            
#             if  random_num not in random_list and  len ( random_list ) < quantity :  # Умова в якій перевіряємо чи згенероване значення вже є в нашому списку ,  *random_list *random_num not in random_list, а також чи наш список містить потрібну кількість елементів, *len ( random_list ) < quantity , де *len ( random_list ) - довжина списку (кількість елементів в списку),  *quantity - пердана у функцію кількість елементів яку має містити наш список.
                
#                 random_list.append ( random_num )  # Добавлємо в наш список згенероване зачення якщо воно відповідає умові. Тобто ще не було в нашому списку *random_list . і поки кількість елементів списку менша за значення в *quantity
#                                                    # Оскільки наш список *random_list початково був порожній то перше згенероване значення обовязково попаде в нього. в список тільки після перевіки буде потрапляти елемент і коли елементів стане 6 то ця умова *len ( random_list ) < quantity  - не виконається і піде на наступний крок  . 

#             elif len ( random_list ) < quantity :  # Додаткова перевірка *elif (або) чи є достатньо елементів в списку оскільки умова *if  random_num not in random_list  не виконається коли хочаб один згенрований елемент буде вже в нашому списку *random_list. 
#                                                    # Нам потрібно повернутись на наступну ітерацію циклу і згенерувати нове значення. 
                
#                 continue                    #  повернутись на наступну ітерацію циклу і в нашом випадку - згенерувати нове значення.

#             else :
                
#                 break   #  Якщо умова *if  random_num not in random_list and  len ( random_list ) < quantity або умова  *elif len ( random_list ) < quantity  не виконалась - значить наш список *random_list містить вже потрібну кількість елементів які відповідають умові завдання . 
#                         #  Перериваємо наш цикл *while True : оператором  *break

#         random_list.sort()    # Сортуємо наш список *random_list в порядку зростання за допомогою методу *список_який_сортуємо.sort()
#                               # Один з варіантів нашого згенерованого випадково списку з заданими тестовими значеннями *[4, 10, 19, 28, 32, 36, 38, 41, 48]   
#                               #   *min = 1, *max = 49, *quantity = 9
        
#         return random_list  # Повертаэмо згенерований відсортований список згідно умов завдання і вказаних тестових зачень.
    
#     else :
#          return random_list  # Якщо перша умова *if min > 0  and max <= 1000 and max > quantity : не виконається відразу перейде на цей крок *else . 
#                             # в нашому *random_list буде початкове значення - пустий список *[] - його і повертаємо з функції. 


# min = 1 # мінімальне можливе випадкове значення .

# max = 49 # Максимальне можливе випадкове значення . (min і  max) - це є вказаний діапазон з якого будемо генерувати випадкові числа які не повторюють.

# quantity = 9 # кількість чисел які потрібно згенерувати (має бути min < quantity < max)

# print ( get_numbers_ticket ( min, max, quantity ) ) # Принтимо результат виконання нашої функції *get_numbers_ticket ( min, max, quantity ) . Він буде кожний раз іншим оскільки при виконанні функції буде генероватись випадкові значення задані умоваою завдання.


# ================================ Звдання 5 / Task 5 ======================================

#  ++++++++++++++++++++ Для генерації випадкових (псевдовипадкових) чисел у Python є пакет random. ++++++++++++++

#     ++++++++++  ЗАВДАННЯ. ВИБІР ПЕРЕМОЖЦІВ РОЗІГРАШУ  ++++++++++++++++++++

# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Ви проводите розіграш кавоварок Bosch серед зареєстрованих користувачів вашої інтернет-сторінки.

# Список зареєстрованих користувачів — це словник такого типу:

# participants = {
#     "603d2cec9993c627f0982404": "test@test.com",
#     "603f79022922882d30dd7bb6": "test11@test.com",
#     "60577ce4b536f8259cc225d2": "test2@test.com",
#     "605884760742316c07eae603": "vitanlhouse@gmail.com",
#     "605b89080c318d66862db390": "elhe2013@gmail.com",
# }
# Ключ словника — це унікальний ідентифікатор бази даних MongoDB, а значення &mdash це email користувача. Вам необхідно випадково відібрати декілька переможців розіграшу.

# Створіть функцію get_random_winners(quantity, participants), 
# яка повертатиме список унікальних ідентифікаторів бази даних зі словника participants в кількості quantity. 
# Це буде список переможців

# Вимоги:

# Отримайте перелік ключів словника. (Після виконання методу keys() використовуйте перетворення типів)
# Перемішайте отриманий список за допомогою методу shuffle
# Виберіть випадкових переможців, використовуючи метод sample.
# Якщо передана кількість переможців більша за кількість користувачів (quantity > len(participants)) — поверніть порожній список.
# Наприклад: виклик get_random_winners(2, participants) може повернути список з випадковим набором ідентифікаторів
# як: ['60577ce4b536f8259cc225d2', '605b89080c318d66862db390'].

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

import random


def get_random_winners ( quantity, participants ) :  # Функція  яка отримує два аргументи. *quantity - типу *int - кількість очікуваних переможців .
                                                    #  *participants - словник ,відповідної форми , з якого будемо оберати вказану в *quantity кількість переможців випадковим чином .
    
    list_all_participants  = list ( participants.keys () ) # *list ( participants.keys () ) # Формуємо список з ключів , з нашого словника *participants методом *імя_словника.keys () - Метод повертає з словника обєкт типу *dict який містить список , сформований з елементів , які є ключами вказаного словника .
                                                   #  -в нашому випадку обєкт словника клучі буде мати такий вигляд : *dict_keys(['603d2cec9993c627f0982404', '603f79022922882d30dd7bb6', '60577ce4b536f8259cc225d2', '605884760742316c07eae603', '605b89080c318d66862db390']) 
                                                   # вбудована функцією *list - (перетворює вхідні дані в список і повертає його ) 
                                                   # Врезультаті наш *list_all_participants буде містити наступний сисок *['603d2cec9993c627f0982404', '603f79022922882d30dd7bb6', '60577ce4b536f8259cc225d2', '605884760742316c07eae603', '605b89080c318d66862db390']
    #print ( list_all_participants )
    
    if len ( list_all_participants ) >= quantity : # Умова в які перевіряємо чи наш списко *list_all_participants більший рівний за значення *quantity - кількость переможців , Оскільки переможців не може бути більше ніж учасників.
                                                    #  якщо умова виконується то далі виконуємо наступні кроки коду. Якщо ні повертаємо пустий список .

        random.shuffle ( list_all_participants )  # Перемішуємо наш список *list_all_participants  за допомогою модуля *random і методу .shuffle (*список_який_перемішуємо) 
                                                  #  *random.shuffle ( list_all_participants ) повертає той самий  список *list_all_participants тільки елементи вньому перемішані випадковим чином. 

        #print ( list_all_participants )

        list_winers_participants = random.sample ( list_all_participants, k = quantity )  # формуємо список наших переможців за допомогою модуля *random і методу .sample ( *імя_списку , k =*кільість випадкових значень які потрібно повернути )
                                        # *random.sample ( list_all_participants, k = quantity ) -поверне в *list_winers_participants *k- кількість випадкових елементів з списку *list_all_participants
    else :
        return []  # Повертаємо пустий список якщо не виконалась перша умова *if len ( list_all_participants ) >= quantity :
    
    return list_winers_participants  # Повертаємо список переможців сформований в відповідності до умови завдання

quantity = 3 # Тестова значення. кількість переможців лотереї.

participants = {
    "603d2cec9993c627f0982404": "test@test.com",
    "603f79022922882d30dd7bb6": "test11@test.com",
    "60577ce4b536f8259cc225d2": "test2@test.com",
    "605884760742316c07eae603": "vitanlhouse@gmail.com",
    "605b89080c318d66862db390": "elhe2013@gmail.com",
                } # Тестови словник з якого будем оберати переможців.

print ( get_random_winners ( quantity, participants ) ) # Принтимо результат роботи нашої функції.
                                                        # одни з варіантів списку переможців повернутий з функції згідно заданих параметрів - *['603d2cec9993c627f0982404', '605884760742316c07eae603', '603f79022922882d30dd7bb6']


