# ===================  Home work 8 ========================

# =================   Можливості деяких вбудованих пакетів Python =================

# =================== Робота з датою і часом (datetime)  ==========================

# Робота з датою і часом у Python реалізована у пакеті datetime. Основні можливості datetime:



# визначення поточної дати і часу;
# обчислення інтервалу між двома подіями;
# визначення дня тижня, високосного року для будь-якої дати у минулому не раніше року datetime.MINYEAR
# або в майбутньому не пізніше року datetime.MAXYEAR;
# порівняння дати і часу декількох подій за допомогою операторів порівняння;
# робота з часовими зонами, порівняння подій з урахуванням часових зон та переходу на літній/зимовий час;
# перетворення дати/часу в рядок і навпаки.
# Щоб отримати поточну дату і час без урахування часового пояса, можна викликати метод now() у datetime:



# from datetime import datetime

# current_datetime = datetime.now()
# print(current_datetime) # 2020-10-09 22:13:35.053819


# У результаті виклику now() ми отримуємо об'єкт datetime, у якого є ряд корисних атрибутів:



# from datetime import datetime

# current_datetime = datetime.now()

# print(current_datetime.year)        # 2020
# print(current_datetime.month)       # 10
# print(current_datetime.day)         # 09
# print(current_datetime.hour)        # 22
# print(current_datetime.minute)      # 32
# print(current_datetime.second)      # 22
# print(current_datetime.microsecond) # 819366


# В об'єкта datetime є методи, щоб отримати дату (без часу) та час (без дати):



# from datetime import datetime

# current_datetime = datetime.now()
# print(current_datetime.date())  # 2020-10-09
# print(current_datetime.time())  # 22:13:35.053819


# Щоб створити об'єкт datetime з будь-якою вибраною датою, можна зробити так:



# from datetime import datetime

# d1 = datetime(year=2012, month=1, day=7, hour=14)
# print(d1) # 2012-01-07 14:00:00


# Щоб дізнатися день тижня, можна скористатися методом weekday:



# from datetime import datetime

# seventh_day_2020 = datetime(year=2020, month=1, day=7, hour=14)
# print(seventh_day_2020.weekday())   # 1


# Дні тижня у Python починаються з понеділка і він буде 0. У прикладі вище 7 Січня 2020 року було вівторком.



# Щоб порівняти два об'єкти datetime, достатньо скористатися оператором порівняння:



# from datetime import datetime

# current_datetime = datetime.now()

# future_month = (current_datetime.month % 12) + 1
# future_year = current_datetime.year + int(current_datetime.month / 12)
# future_datetime = datetime(future_year, future_month, 1)

# print(current_datetime < future_datetime)    # True


# ================================ Звдання 1 / Task 1 ======================================

# ++++++++   Робота з датою і часом у Python реалізована у пакеті datetime +++++++++++++++

# Основні можливості datetime:

# визначення поточної дати і часу;
# обчислення інтервалу між двома подіями;
# визначення дня тижня, високосного року для будь-якої дати у минулому не раніше року datetime.MINYEAR 
# або майбутньому не пізніше року datetime.MAXYEAR;
# порівняння дати і часу декількох подій за допомогою операторів порівняння;
# робота з часовими зонами, порівняння подій з урахуванням часових зон та переходу на літній/зимовий час;
# перетворення дати/часу в рядок і навпаки.
# DATETIME
# Щоб отримати поточну дату і час без урахування часового пояса, можна викликати метод now() у datetime:

# from datetime import datetime

# current_datetime = datetime.now()
# print(current_datetime) # 2020-10-09 22:13:35.053819
# У результаті виклику now() ми отримуємо об'єкт datetime, у якого є ряд корисних атрибутів:

# from datetime import datetime

# current_datetime = datetime.now()

# print(current_datetime.year)        # 2020
# print(current_datetime.month)       # 10
# print(current_datetime.day)         # 09
# print(current_datetime.hour)        # 22
# print(current_datetime.minute)      # 32
# print(current_datetime.second)      # 22
# print(current_datetime.microsecond) # 819366
# У об'єкту datetime є методи, щоб отримати дату (без часу) та час (без дати):

# from datetime import datetime

# current_datetime = datetime.now()
# print(current_datetime.date())  # 2020-10-09
# print(current_datetime.time())  # 22:13:35.053819
# Щоб створити об'єкт datetime з будь-якою вибраною датою, можна зробити так:

# from datetime import datetime

# d1 = datetime(year=2012, month=1, day=7, hour=14)
# print(d1) # 2012-01-07 14:00:00
# Щоб дізнатися день тижня, можна скористатися методом weekday:

# from datetime import datetime

# seventh_day_2020 = datetime(year=2020, month=1, day=7, hour=14)
# print(seventh_day_2020.weekday())   # 1
# Дні тижня у Python починаються з понеділка і він буде 0. У прикладі вище 7 Січня 2020 року було вівторком.

# Щоб порівняти два об'єкти datetime, досить скористатися оператором порівняння.

# TIMEDELTA
# Якщо відняти від одного datetime об'єкту інший, то отримаємо timedelta об'єкт. Він відповідає за відрізок часу між двома датами.

# from datetime import datetime

# seventh_day_2019 = datetime(year=2019, month=1, day=7, hour=14)
# seventh_day_2020 = datetime(year=2020, month=1, day=7, hour=14)

# difference = seventh_day_2020 - seventh_day_2019
# print(difference)                   # 365 days, 0:00:00
# print(difference.total_seconds())   # 31536000.0
# Об'єкти timedelta можна створювати самостійно щоб отримати дату/час віддалену від початкової:

# from datetime import datetime, timedelta

# seventh_day_2020 = datetime(year=2020, month=1, day=7, hour=14)
# four_weeks_interval = timedelta(weeks=4)

# print(seventh_day_2020 + four_weeks_interval)   # 2020-02-04 14:00:00
# print(seventh_day_2020 - four_weeks_interval)   # 2019-12-10 14:00:00
# Об'єкт timedelta можна створити, задаючи тижні, дні, години, хвилини, секунди, мілісекунди і мікросекунди:

# from datetime import timedelta
# delta = timedelta(
#     days=50,
#     seconds=27,
#     microseconds=10,
#     milliseconds=29000,
#     minutes=5,
#     hours=8,
#     weeks=2
# )
# Якщо якийсь параметр не заданий, то він дорівнює 0 за умовчанням.

# Робота з часовими поясами припускає знання класів у Python і ми розглянемо її пізніше.

# TIMESTAMP
# Окремо треба сказати про timestamp. timestamp — це кількість секунд, що пройшло з 00 годин 00 хвилин 1 Січня 1970 року 
# у UTC (часовий пояс Грінвіча). Це просто прийнята константа і нічого особливого вона не означає. 
# Просто для зручності колись почали відлічувати час в секундах з цієї миті і це виявилося дуже зручно. 
# Адже порівняти два числа завжди легше і швидше, чим порівняти складну структуру дат і часів.

# Звичайно можна з timestamp отримати дату/час і навпаки:

# from datetime import datetime

# seventh_day_2020 = datetime(year=2020, month=1, day=7, hour=14)
# ts = seventh_day_2020.timestamp()
# print(ts)   # 1578398400.0

# ts += 100_000
# print(datetime.fromtimestamp(ts))   # 2020-01-08 17:46:40

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Розробіть функцію get_days_from_today(date), яка повертатиме кількість днів від поточної дати,
# де параметр date - це рядок формату '2020-10-09' (рік-місяць-день).

# Підказки:

# Параметр date розбити на рік, місяць та день можна використовуючи метод рядків split.
# datetime приймає аргументи типу int, використовуйте перетворення типів.
# ігноруйте години, хвилини та секунди для вашої дати, важливі повні дні.
# кількість днів ви можете отримати відніманням з поточної дати, заданої в змінній date (без часу).
# Наприклад: Якщо поточна дата - '5 травня 2021', то виклик get_days_from_today("2021-10-09") поверне нам -157.


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from datetime import datetime  # З бібліотеки *datetime  імпортуємо функцію *datetime . Бібліотека для роботи з датою і часом.


# def get_days_from_today ( date ) : # Функція яка приймає оди аргумент . *date (тип *str ) формату 'Рік-Місяць-День' # '2024-10-09'
#                                    # Повертає ціле число днів (тип *int) від поточної дати до вказаної в *date .
#                                    # якщо *date -містить майбутню дату (та яка має настати від поточної) То повертає відємне число днів.
#                                    # якщо *date -містить минулу дату (та яка вже відбулась  від поточної) То повертає додатнє число днів

#     list_some_date = date.split ('-')  # Передану у функцію дату *date типу рядок . Розділяємо методом *.split ('-') - по знаку тире "-"
#                                        # отримаємо у *list_some_date список із 3 елементів ,для ашого тестового значення - *['2024', '10', '09']. 
#                                        #  Де перший елемент списку '2024'- це рік, Другий - '10' -місяць, Третій '09' - день 

#     some_date =  datetime ( year = int ( list_some_date [0] ), month = int ( list_some_date [1] ), day = int ( list_some_date [2] ) ) # 
#                         # За допомогою вбудованої функції *datetime ( year = *int , month = *int, day = *int ) в зміну *some_date передаєм обєкт типу *datetime 
#                         #  В *year передаєм перший елемент з списку *list_some_date приведений до типу *int .  *int ( list_some_date [0] ) = 2024
#                         #  В *month передаєм другий елемент з списку *list_some_date приведений до типу *int .  *int ( list_some_date [1] ) = 10
#                         #  В *day передаєм третій  елемент з списку *list_some_date приведений до типу *int . *int ( list_some_date [2] ) = 09
#                         # Функція *datetime - містить ще інші парметри зокрема години , хв , секунди , мікросекунди . Але для нашого завдання ці дані непотрібні.
#                         # Всі параметри які не передані у фцнкцію замінняються 00 - нулями .
#                         # Тому для нашого випадку *some_date = 2024-10-09 00:00:00
    
#     # print ( list_some_date)
#     # print ( some_date )

#     data_now = datetime.now() # Предаєм у зміну *data_now поточне значення дати і часу за допомогою вбудованої функції *datetime і методу *.now() . 
#                               # Для нашого тестового значення 2023-12-30 07:34:52.039276 ( точний час на момент запуску коду)

#     # print (data_now )

#     data_diferent_curent = data_now.date() - some_date.date() # Порівнюємо два обєкти *datetime віднімаючи їх і результат передаємо в *data_diferent_curent
#                                                               # *data_diferent_curent = -284 days, 0:00:00
#     print ( data_diferent_curent)


#     return  data_diferent_curent.days  # повертаємо з нашої функції значення *data_diferent_curent - приведеного до форми *.days . 
#                                        # Метод *.days застосований до обєкта *datetime повертає з обєкта ціле число днів. 
#                                        # Якщо дата з майбутнього то відємне число. В нашому прикладі вказано майбутню дату ому поверне 
#                                        # -284

   


# date = '2024-10-09'  #  Тестове значення


# print ( get_days_from_today ( date ) )  # Принтимо результат роботи нашої функції  * get_days_from_today ( date ) = -284


# ================================ Звдання 2 / Task 2 ======================================

#   КІЛЬКІСТЬ ДНІВ НА МІСЯЦЬ

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Напишіть функцію визначення кількості днів у конкретному місяці. Ваша функція повинна приймати два параметри: 
# month - номер місяця у вигляді цілого числа в діапазоні від 1 до 12 і year - рік, що складається із чотирьох цифр. 
# Перевірте, чи функція коректно обробляє місяць лютий високосного року.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from datetime import date  #  З бібліотеки *datetime  імпортуємо функцію *datetime  . Бібліотека для роботи з датою і часом.

# DAYS_in_MONTH = { '1': 31, '2': 28, '3': 31, '4': 30, '5': 31, '6': 30, '7': 31, '8': 31, '9': 30, '10': 31, '11': 30, '12': 31
   
#                     }  # Словник який містить ключами місяці а значеннями кількість днів в цьому місяці . Для невисокосних років.

# DAYS_in_MONTH_VYSOKOS = { '1': 31, '2': 29, '3': 31, '4': 30, '5': 31, '6': 30, '7': 31, '8': 31, '9': 30, '10': 31, '11': 30, '12': 31
   
#                             }  # Словник який містить ключами місяці а значеннями кількість днів в цьому місяці . Для високосних років.

# def vysokosnyj_year ( year ) : # Допоміжна функція . яка визначає чи перданий в функцію рік високосний.
#                                # Приймає один аргумент . Ціле число . Повертає *True -якщо високосний і *False якщо ні.
    
#     if  ( ( year % 4 == 0 ) and ( year % 100 != 0 ) or ( year % 400 == 0 ) ) : #Високочний рік повинен бути кратним 4 і не кратним 100 або кратним 400 .
       
#        vysokosnyj_year  = True  # Якщо виконалась умова *if ... Значить рік високосний присвоюємо в *vysokosnyj_year = *True

#     else:
      
#       vysokosnyj_year  = False  #  Якщо не виконалась умова *if ... Значить рік не високосний присвоюємо в *vysokosnyj_year = *False
    
#     return vysokosnyj_year  #  Повертаємо значення присвоюємо в *vysokosnyj_year . 


# def get_days_in_month ( month, year ) :  # Основна фінкція . В ній перевіряємо чи переданий рік в *year високисний чи ні за допомогою функції *vysokosnyj_year ( year )
#                                          #  Далі якщо високосний то повертаємо відповідне значення днів за ключем *month  з нашого словника *DAYS_in_MONTH_VYSOKOS
#                                          #  якщо не високосний то повертаємо відповідне значення днів за ключем *month  з нашого словника *DAYS_in_MONTH
    
#     month = str ( month )  #  Приводимо наш month до типу *str і переприсовоюємо це значення в *month

     
#     if vysokosnyj_year ( year ) :  #  перевіряємо повернутий результат з функції *vysokosnyj_year ( year ) якщо високосний поверне *True
                                   

#         days_in_month = DAYS_in_MONTH_VYSOKOS.get ( month )  # Якщо виконалась умова *if... То повертаємо відповідне значення для ключа * month з нашого словника *DAYS_in_MONTH_VYSOKOS 
#                                                             #  для тестових значень *year = 2020 і *month = 2  Поверне -  29

        
     
#         return days_in_month   # Повертаємо з функції значення *days_in_month
    
#     else :
       
#        days_in_month = DAYS_in_MONTH.get ( month )  # # Якщо не виконалась умова *if... То повертаємо відповідне значення для ключа * month  з нашого словника *DAYS_in_MONTH
#                                                     #  для тестових значень *year = 2020 і *month = 2  Поверне -  28
       
#        return days_in_month    #
       

# month = 2  #  Тестове значення місяць Лютий . Для високосного року 29 днів 

# year = 2020  # Тестове значення високосний рік . 

# month = 2  # Тестове значення місяць Лютий . Для звичного  року 28 днів 

# year = 2021  # Не вискосний рік

# print ( get_days_in_month ( month, year ) )   # Прінтимо значення повернуті в результаті виконання нашої фцнкції *get_days_in_month ( month, year )
#                                             #  Для звчайного року Лютий ( 2 місяць року) видасть 28 .
#                                             #  Для високосного року Лютий ( 2 місяць року) видасть 29 .



# ================================ Звдання 3 / Task 3 ======================================

#  ++++++++++++++++++++ Перетворення дати  в інший формат  Метод *імя_обєкта_datatime*.strftime ( '%A %d %B %Y' ) ++++++++++++++

# ++++++++++++++++++++++++++++++++++++  Короткий опис методу *імя_обєкта_datatime*.strftime ( '%A %d %B %Y' ) , всі можливі формати шукай в інтернету +++++++

# date.strftime ( '%A %d %B %Y' ) # Формуємо потрібний нам формат дати за допомогою методу *date.strftime ( '%A %d %B %Y' ) . в нашому випадку = *Thursday 27 May 2021

                                    # меод *date.strftime ( '%A %d %B %Y' ) повертає з зміної *date ,яка містить обєкт *datatime ,- рядок вказаного формату 
                                    # де *date - імя_яке_містить_обєкт_datetime ,
                                    #  *( '%A %d %B %Y' ) - формат який треба повернут. 
                                    #  В нашому *( ' %A %d %B %Y ' ) ='Thursday 27 May 2021'
                                    # параметер  *%A - це конкретний день тижня (з понеділка по неділю (англійською) включно , на який вказує задане число , місяць і рік ) в нашому випадку *Thursday . 
                                    # параметер  *%a - виводить те саме що й *%A тільки в короткому записі . для нашого випадку *%a = Thu . в нашому завданні не застосовуємо.
                                    # параметер *%d - це конкретне число з календаря . В нашому випадку *%d = 27 
                                    # параметер *%m  - це цифровий запис конкретного місяця з обєкту *datatime . *%m = 05 (в нашому випадку не застосовуємо)
                                    # параметер *%B - це словесне значення конкретного місяця (з січння по грудень (англійською) на який вказує цифоровий запис з *month з обєкту *datatime ) в нашому випадку month = 05 отже *%B = May
                                    # параметр  *%Y - це рік з обєкту  *datetime

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


# Коли треба перетворити дату/час в рядок, ви можете скористатися функцією str, яка перетворить datetime у рядок. 
# Але часто формат такого перетворення незручний і в Python є окрема міні-мова для опису, як перетворити дату/час в рядок:

# from datetime import datetime

# seventh_day_2020 = datetime(year=2020, month=1, day=7, hour=14)
# print(seventh_day_2020.strftime('%A %d %B %Y')) # Tuesday 07 January 2020
# Та ж міні-мова використовується для конвертації вже рядків в дату/час:

# from datetime import datetime

# s = '10 January 2020'
# print(datetime.strptime(s, '%d %B %Y')) # 2020-01-10 00:00:00
# Деталі можна вивчити на сторінці офіційної документації.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Напишіть функцію get_str_date(date), яка перетворюватиме дату з бази даних у форматі ISO '2021-05-27 17:08:34.149Z' 
# у вигляді наступного рядка 'Thursday 27 May 2021' - день тижня, число, місяць та рік. 
# Перетворене значення функція повертає під час виклику.


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from datetime import datetime 


# def format_date_year_month_day ( date ) : # Допоміжна функція яка отримує один аргумент в вигляді рядка формату '2021-05-27 17:08:34.149Z' Де дата від часу відділяється одним пробілом.
#                                           # і повртає список із 3 елементів . Пеший рік , другий місяць , третій день. Для нашого тестового значення
#                                           #   '2021-05-27 17:08:34.149Z' поверне ['2021', '05', '27']

#     date_without_time = date.split ( " " )[0] # за добпомогою методу . *.split( " " ) розбиваэмо наш рядок *date за пробілом . Метод *.split- поверне  в память нам список із двох елементів в нашому випадку для *'2021-05-27 17:08:34.149Z'
#                                              #  буде ['2021-05-27', '17:08:34.149Z'] і відразу беремо 1 елемент з того списку *[0]-вказує на 1 елемент з списку- і присвоюємо в зміну *date_without_time
#                                             #  Тобто такий запис *date.split( " " )[0] присвоїть в нашу зміну *date_without_time = '2021-05-27' для нашого тестового значення.
#     # print ( date_without_time )
#     list_date_without_time = date_without_time.split ( '-' ) # Отриманий рядок в *date_without_time розбиваємо ще раз методом .split() але вже по сиволу тире "-"
#                                                             #   Отримаємо список з 3 елементів для нашого тестового значення , його і присвоюємо в зміну *list_date_without_time
                                                            

#     return list_date_without_time   # Повертаємо наш список з функції *list_date_without_time = ['2021', '05', '27'] для *date'2021-05-27 17:08:34.149Z'

# def get_str_date ( date ) : # Основна функція яка отримує один аргумент типу рядок наступного формату  *'2021-05-27 17:08:34.149Z' 
#                             #  і повертає рядок вже зміненого формату  *'Thursday 27 May 2021'
    
#     list_date_without_time = format_date_year_month_day ( date ) # За допомогою нашої допоміжної функції *format_date_year_month_day ( date ) повертаємо в  *list_date_without_time список із 3 елемнтів формату рік, місяць і день з вказного рядка в *date
#                                                                 #  *list_date_without_time = ['2021', '05', '27']
#     # print (list_date_without_time)

#     date = datetime ( year = int ( list_date_without_time[0] ), month = int ( list_date_without_time[1] ) ,  day = int ( list_date_without_time[2]) ) # переприсвоюємо  в *date обєкт datetime ( year = *int , month = *int, day = *int) з відповідними значеннями з списку *list_date_without_time
#                                     # Для нашого тестового завдання *date = 2021-05-27 00:00:00 де час буде заповнено 0 оскільки ми його не передавали в вбудовану  функцію *datetime()
#     # print ( date )
#     str_date = date.strftime ( '%A %d %B %Y' ) # Формуємо потрібний нам формат дати за допомогою методу *date.strftime ( '%A %d %B %Y' ) і присвоюємо в *str_date
#                                     # меод *date.strftime ( '%A %d %B %Y' ) повертає з зміної *date ,яка містить обєкт *datatime ,- рядок вказаного формату 
#                                     # де *date - імя_яке_містить_обєкт_datetime , *( '%A %d %B %Y' ) - формат який треба повернут. 
#                                     #  В нашому *( ' %A %d %B %Y ' ) ='Thursday 27 May 2021'
#                                     # параметер  *%A - це конкретний день тижня (з понеділка по неділю (англійською) включно , на який вказує задане число , місяць і рік ) в нашому випадку *Thursday . 
#                                     # параметер  *%a - виводить те саме що й *%A тільки в короткому записі . для нашого випадку *%a = Thu . в нашому завданні незастосовуємо.
#                                     # параметер *%d - це конкретне число . В нашому випадку *%d = 27 ( *%m (05) - це цифровий запис конкретного місяця з обєкту *datatime - в нашому випадку не застосовуємо)
#                                     # параметер *%B - це словесне значення конкретного місяця (з січння по грудень (англійською) на який вказує цифоровий запис з *month з обєкту *datatime ) в нашому випадку month = 05 отже *%B = May
#                                     # параметр  *%Y - це рік з обєкту  *datetime
                                    
#     # print ( date )
#     return str_date  # Повертаємо з функції потрібний результа вказаного формату в завданні. *str_date = 'Thursday 27 May 2021'

    

# date = '2021-05-27 17:08:34.149Z' # Тестове значення .

# print ( get_str_date ( date ) )  # Принтимо повернутий рядок потрібного формату - *Thursday 27 May 2021



# ================================ Звдання 4 / Task 4 ======================================

#  ++++++++++++++++++++ Для генерації випадкових (псевдовипадкових) чисел у Python є пакет random. ++++++++++++++

#     ++++++++++  короткий опис пакету і методів random   ++++++++++++++++++++

# Для генерації випадкових (псевдовипадкових) чисел у Python є пакет random. 
# Він досить хороший для ряду побутових завдань, але не для криптографії. 
# На жаль вбудований генератор псевдовипадкових чисел досить скоро починає повторюватися і не є досить криптостійким. 
# Проте, для прикладних завдань поза сферою криптографії його цілком вистачає.

# Отримання випадкового цілого числа з рівномірного розподілу в інтервалі між 1 та 1000 включно:

# import random

# random.randint(1, 1000)
# Якщо треба отримати випадкове число в інтервалі 0, 1 включно:

# import random

# random.random()
# Коли у вас є список об'єктів і вам потрібно перемішати порядок елементів в цьому списку на випадковий:

# import random

# fruits = ['apple', 'banana', 'orange']
# random.shuffle(fruits)
# print(fruits)   # ['banana', 'orange', 'apple']
# Якщо потрібно вибрати випадковий елемент зі списку:

# import random

# fruits = ['apple', 'banana', 'orange']
# print(random.choice(fruits))   # 'banana'
# Щоб вибрати N випадкових елементів зі списку:

# import random

# fruits = ['apple', 'banana', 'orange']
# print(random.choices(fruits, k=4))   # ['banana', 'orange', 'orange', 'orange']
# Щоб вибрати N елементів, що не повторюються, зі списку:

# import random

# fruits = ['apple', 'banana', 'orange']
# print(random.sample(fruits, k=2))   # ['banana', 'orange']
# Зверніть увагу, що k не може бути більше довжини fruits.

# Якщо вам треба скористатися відмінним від рівномірного розподілу, можете вибрати один із підтримуваних розподілів.

# Щоб випадково вибрати число із послідовності:

# import random

# print(random.randrange(1, 11))
# Функція random.randrange поверне довільне число від 1 до 10 включно. Зазначене під час виклику число 11 не з'явиться при виклику функції.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Щоб виграти головний приз лотереї, необхідний збіг кількох номерів на лотерейному квитку з числами, 
# що випали випадковим чином і в певному діапазоні під час чергового тиражу. Наприклад,
# необхідно вгадати шість чисел від 1 до 49 чи п'ять чисел від 1 до 36 тощо.

# Напишіть функцію, яка випадково підбиратиме набір чисел для лотерейного квитка. Серед цих чисел не має бути дублікатів.

# Формат функції get_numbers_ticket(min, max, quantity), де параметри:

# min - мінімальне значення діапазону, не може бути менше 1
# max - максимальне значення діапазону, не може бути більше 1000
# quantity - кількість чисел у наборі (має бути min < quantity < max)
# Функція повинна повернути перелік випадкових чисел за зростанням. Якщо порушено умови обмежень на параметри функції, 
# тоді повернути пустий список.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# import random # Імпортуємо бібліотеку randomn для роботи з її функціями і методами. Бібліотека генерування випадковостей.

# from random import randrange # З бібліотеки  random імпортуємо метод *randrange (*діапазон) генерує випадкове число з вказаного діапазону.
#                             #   *random.randrange ( min, max ) де *random - вбудований модуль, *.randrange - метод генерації випадкового значення з вказаного діапазону.
#                             #  min - мінімаьне можливе значення , max - максимально можливе значення . min і max - значення  включно .

# def get_numbers_ticket ( min, max, quantity ) :  # Функція приймає 3 параметри типу *int . Повертає список який містить *quantity елементів , відсортованих в порядку зростання ,  згенерованих випадковим чином  з вказаного діапазону *min і *max
#                                                  # якщо *min,  *max і *quantity не відповідають вимогам умови завдання повертає пустий список *[] .
    

#     random_list = []  #  *random_list - список в який будемо записувати наші згенеровані значення і повертати з функції . Початкове значення пустий список *[] .
   

#     if min > 0  and max <= 1000 and max > quantity :  # Умова для перевірки вхідних значень.  
#                                                       # *min - мінімальне значення діапазону, не може бути менше , *min > 0 
#                                                       # *max - максимальне значення діапазону, не може бути більше 1000 , *max <= 1000
#                                                       #  Максимальне значення діапазону має бути більше кількості чисел які потрібно згенерувати. *max > *quantity  

#         while True :   # Генерувати наш список випадкових чисел будемо в циклі *while . 
#                        # Як тільки отримаємо потрібну кількість значень перериваємо цикл оператором *break

#             random_num = random.randrange ( min, max )  # в зміну *random_num присвоюємо , випадковим чином згенероване ,  значення з діапазону ( min, max ) за допомгою вбудованої фінкці *random і методу *.randrange ( min, max )
            
#             if  random_num not in random_list and  len ( random_list ) < quantity :  # Умова в якій перевіряємо чи згенероване значення вже є в нашому списку ,  *random_list *random_num not in random_list, а також чи наш список містить потрібну кількість елементів, *len ( random_list ) < quantity , де *len ( random_list ) - довжина списку (кількість елементів в списку),  *quantity - пердана у функцію кількість елементів яку має містити наш список.
                
#                 random_list.append ( random_num )  # Добавлємо в наш список згенероване зачення якщо воно відповідає умові. Тобто ще не було в нашому списку *random_list . і поки кількість елементів списку менша за значення в *quantity
#                                                    # Оскільки наш список *random_list початково був порожній то перше згенероване значення обовязково попаде в нього. в список тільки після перевіки буде потрапляти елемент і коли елементів стане 6 то ця умова *len ( random_list ) < quantity  - не виконається і піде на наступний крок  . 

#             elif len ( random_list ) < quantity :  # Додаткова перевірка *elif (або) чи є достатньо елементів в списку оскільки умова *if  random_num not in random_list  не виконається коли хочаб один згенрований елемент буде вже в нашому списку *random_list. 
#                                                    # Нам потрібно повернутись на наступну ітерацію циклу і згенерувати нове значення. 
                
#                 continue                    #  повернутись на наступну ітерацію циклу і в нашом випадку - згенерувати нове значення.

#             else :
                
#                 break   #  Якщо умова *if  random_num not in random_list and  len ( random_list ) < quantity або умова  *elif len ( random_list ) < quantity  не виконалась - значить наш список *random_list містить вже потрібну кількість елементів які відповідають умові завдання . 
#                         #  Перериваємо наш цикл *while True : оператором  *break

#         random_list.sort()    # Сортуємо наш список *random_list в порядку зростання за допомогою методу *список_який_сортуємо.sort()
#                               # Один з варіантів нашого згенерованого випадково списку з заданими тестовими значеннями *[4, 10, 19, 28, 32, 36, 38, 41, 48]   
#                               #   *min = 1, *max = 49, *quantity = 9
        
#         return random_list  # Повертаэмо згенерований відсортований список згідно умов завдання і вказаних тестових зачень.
    
#     else :
#          return random_list  # Якщо перша умова *if min > 0  and max <= 1000 and max > quantity : не виконається відразу перейде на цей крок *else . 
#                             # в нашому *random_list буде початкове значення - пустий список *[] - його і повертаємо з функції. 


# min = 1 # мінімальне можливе випадкове значення .

# max = 49 # Максимальне можливе випадкове значення . (min і  max) - це є вказаний діапазон з якого будемо генерувати випадкові числа які не повторюють.

# quantity = 9 # кількість чисел які потрібно згенерувати (має бути min < quantity < max)

# print ( get_numbers_ticket ( min, max, quantity ) ) # Принтимо результат виконання нашої функції *get_numbers_ticket ( min, max, quantity ) . Він буде кожний раз іншим оскільки при виконанні функції буде генероватись випадкові значення задані умоваою завдання.


# ================================ Звдання 5 / Task 5 ======================================

#  ++++++++++++++++++++ Для генерації випадкових (псевдовипадкових) чисел у Python є пакет random. ++++++++++++++

#     ++++++++++  ЗАВДАННЯ. ВИБІР ПЕРЕМОЖЦІВ РОЗІГРАШУ , методи *random.sample ( *list , *k= ) , *random.shuffle ( *list )++++++++++++++++++++

# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Ви проводите розіграш кавоварок Bosch серед зареєстрованих користувачів вашої інтернет-сторінки.

# Список зареєстрованих користувачів — це словник такого типу:

# participants = {
#     "603d2cec9993c627f0982404": "test@test.com",
#     "603f79022922882d30dd7bb6": "test11@test.com",
#     "60577ce4b536f8259cc225d2": "test2@test.com",
#     "605884760742316c07eae603": "vitanlhouse@gmail.com",
#     "605b89080c318d66862db390": "elhe2013@gmail.com",
# }
# Ключ словника — це унікальний ідентифікатор бази даних MongoDB, а значення &mdash це email користувача. Вам необхідно випадково відібрати декілька переможців розіграшу.

# Створіть функцію get_random_winners(quantity, participants), 
# яка повертатиме список унікальних ідентифікаторів бази даних зі словника participants в кількості quantity. 
# Це буде список переможців

# Вимоги:

# Отримайте перелік ключів словника. (Після виконання методу keys() використовуйте перетворення типів)
# Перемішайте отриманий список за допомогою методу shuffle
# Виберіть випадкових переможців, використовуючи метод sample.
# Якщо передана кількість переможців більша за кількість користувачів (quantity > len(participants)) — поверніть порожній список.
# Наприклад: виклик get_random_winners(2, participants) може повернути список з випадковим набором ідентифікаторів
# як: ['60577ce4b536f8259cc225d2', '605b89080c318d66862db390'].

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# import random


# def get_random_winners ( quantity, participants ) :  # Функція  яка отримує два аргументи. *quantity - типу *int - кількість очікуваних переможців .
#                                                     #  *participants - словник ,відповідної форми , з якого будемо оберати вказану в *quantity кількість переможців випадковим чином .
    
#     list_all_participants  = list ( participants.keys () ) # *list ( participants.keys () ) # Формуємо список з ключів , з нашого словника *participants методом *імя_словника.keys () - Метод повертає з словника обєкт типу *dict який містить список , сформований з елементів , які є ключами вказаного словника .
#                                                    #  -в нашому випадку обєкт словника клучі буде мати такий вигляд : *dict_keys(['603d2cec9993c627f0982404', '603f79022922882d30dd7bb6', '60577ce4b536f8259cc225d2', '605884760742316c07eae603', '605b89080c318d66862db390']) 
#                                                    # вбудована функцією *list - (перетворює вхідні дані в список і повертає його ) 
#                                                    # Врезультаті наш *list_all_participants буде містити наступний сисок *['603d2cec9993c627f0982404', '603f79022922882d30dd7bb6', '60577ce4b536f8259cc225d2', '605884760742316c07eae603', '605b89080c318d66862db390']
#     #print ( list_all_participants )
    
#     if len ( list_all_participants ) >= quantity : # Умова в які перевіряємо чи наш списко *list_all_participants більший рівний за значення *quantity - кількость переможців , Оскільки переможців не може бути більше ніж учасників.
#                                                     #  якщо умова виконується то далі виконуємо наступні кроки коду. Якщо ні повертаємо пустий список .

#         random.shuffle ( list_all_participants )  # Перемішуємо наш список *list_all_participants  за допомогою модуля *random і методу .shuffle (*список_який_перемішуємо) 
#                                                   #  *random.shuffle ( list_all_participants ) повертає той самий  список *list_all_participants тільки елементи вньому перемішані випадковим чином. 

#         #print ( list_all_participants )

#         list_winers_participants = random.sample ( list_all_participants, k = quantity )  # формуємо список наших переможців за допомогою модуля *random і методу .sample ( *імя_списку , k =*кільість випадкових значень які потрібно повернути )
#                                         # *random.sample ( list_all_participants, k = quantity ) -поверне в *list_winers_participants *k- кількість випадкових елементів з списку *list_all_participants
#     else :
#         return []  # Повертаємо пустий список якщо не виконалась перша умова *if len ( list_all_participants ) >= quantity :
    
#     return list_winers_participants  # Повертаємо список переможців сформований в відповідності до умови завдання

# quantity = 3 # Тестова значення. кількість переможців лотереї.

# participants = {
#     "603d2cec9993c627f0982404": "test@test.com",
#     "603f79022922882d30dd7bb6": "test11@test.com",
#     "60577ce4b536f8259cc225d2": "test2@test.com",
#     "605884760742316c07eae603": "vitanlhouse@gmail.com",
#     "605b89080c318d66862db390": "elhe2013@gmail.com",
#                 } # Тестови словник з якого будем оберати переможців.

# print ( get_random_winners ( quantity, participants ) ) # Принтимо результат роботи нашої функції.
                                                        # одни з варіантів списку переможців повернутий з функції згідно заданих параметрів - *['603d2cec9993c627f0982404', '605884760742316c07eae603', '603f79022922882d30dd7bb6']


# ================================ Звдання 6 / Task 6 ======================================

#  ++++++++++++++++++++ Пакет decimal , точність обчислення, значущі цифри .Функція  *getcontext().prec , тип даних *Decimal ++++++++++++++

# Комп'ютер усі обчислення робить в бінарному вигляді, а десяткові числа використовуються тільки для "спілкування" з користувачем для зручності останнього. Через це і із-за того, що точність обчислень в комп'ютері обмежена, виникають помилки скруглення під час виконання математичних операцій.

# print(0.1 + 0.2 == 0.3)  # False
# print(0.1 + 0.2)  # 0.30000000000000004
# Перший вираз може збити вас з пантелику, оскільки математика стверджує однозначно, що 0.1 + 0.2 = 0.3.
#  Але помилка скруглення під час виконання обчислювальних операцій з дійсними числами у двійковій системі обчислення призводить 
# до такої неоднозначності.

# Проблема точності обчислень так і не розв'язана остаточно, і математика продовжує розвиватися в цьому напрямі.

# Щоб контролювати точність обчислень більш явно, у Python є пакет decimal.

# from decimal import Decimal, getcontext

# getcontext().prec = 6
# Decimal(1) / Decimal(7)  # Decimal('0.142857')

# getcontext().prec = 28
# Decimal(1) / Decimal(7)  # Decimal('0.1428571428571428571428571429')
# У цьому прикладі ми вирахували вираз 1 / 7 з точністю в 6 знаків після коми та в 28 знаків. 
# Щоб встановити точність обчислення, ми скористалися функцією getcontext, яка повертає поточні налаштування точності, 
# та встановили налаштування prec у 6 та 28 відповідно.

# Примітка: prec – це кількість значущих цифр, у попередньому прикладі нуль не має значення.

# Значущі цифри числа
# Якщо число записане як десятковий дріб — то це всі його цифри, починаючи з першої зліва, відмінної від нуля. 
# Так, для числа `3.240` значущі цифри будуть відповідно `3`, `2`, `4`, `0`, а для `0.0167` - це `1`, `6`, `7`.
# Числа `14.5`, `1.45`, `0.145`, `0.0145` мають одні й ті самі значущі цифри: `1`, `4` та `5`.

# from decimal import Decimal, getcontext

# getcontext().prec = 6
# print(Decimal(15) / Decimal(7))  # 2.14286
# Тепер перед десятичною комою також стоїть цифра 2, але кількість значущих цифр залишилось 6.

# Об'єкти Decimal поводяться так само, як float, але їх і не можна використовувати в одному виразі разом. 
# Виконання виразу виду Decimal(0.1) + 0.2 призведе до помилки.

# Повертаючись до нашого прикладу із додаванням 0.1 та 0.2:

# from decimal import Decimal, getcontext

# getcontext().prec = 6
# float(Decimal(0.1) + Decimal(0.2)) == 0.3  # True
# На жаль, Decimal має ще ту особливість, що при створенні Decimal із float його точність береться максимальною для цієї платформи, 
# а не з налаштувань getcontext.

# Саме тому:

# Decimal(0.2) + Decimal(0.1) == Decimal(0.3)  # False
# але

# Decimal(0.2) + Decimal(0.1) == Decimal(0.3) + Decimal(0.0)  # True
# При конвертації в float точність береться з налаштувань getcontext.

#  # ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Створіть функцію decimal_average(number_list, signs_count), яка обчислюватиме середнє арифметичне типу Decimal з кількістю 
# значущих цифр signs_count. Параметр number_list — список чисел

# Увага
# Не забувайте приводити всі числа у списку до типу `decimal`

# Приклад:

# виклик функції decimal_average([3, 5, 77, 23, 0.57], 6) поверне 21.714
# виклик функції decimal_average([31, 55, 177, 2300, 1.57], 9) поверне 512.91400



# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from decimal import Decimal, getcontext  # З бібілотеки  *decimal  імпортуємо клас Decimal і фукцію *getcontext()


# def decimal_average ( number_list, signs_count ) :  # Функція яка обчислюватиме середнє арифметичне типу Decimal . Приямає два аргументи . 
#                                                     # де *number_list — список чисел типу *list з яких потрібно вирахувати середнє арифметична.
#                                                     # *signs_count - кількість значущих цифр для даних типу  *Decimal
#                                                     # Коментар : Арифмети́чне сере́днє (в математиці і статистиці) — сума всіх фіксованих значень набору, поділена на кількість елементів набору

#     list_number_list_in_Decimal = []  # *list_number_list_in_Decimal в який будемо додавати наші значення з списку *number_list але записані в форматі  *Decimal з вказаною кількістю занчемих цифр з *signs_count

#     for element in number_list :  # Цикли в якому будемо формувати наш список *list_number_list_in_Decimal , Берем кожен елемент з списку *number_list і приводемо його до типу Decimal з вказаною в *signs_count значемих цифр . Сформований елемент добавляємо в список *list_number_list_in_Decimal

#         getcontext().prec =  signs_count  # *getcontext().prec Функція  яка задає всім обєктам типу *Decimal вказану кількість знаків , Метод *.prec , застосований до функції *getcontext(),  - повертає з всіх обєктів *Decimal вказану кількість значущих цифр. 

#                                           #   для нашого значення  *signs_count = 6 всі обєкти Decimal будуть містити тільки 6 значемих цифр. 
#         list_number_list_in_Decimal.append ( Decimal (element) ) # Додаємо  поточний елемент з списку *number_list , приведений до типу *Decimal , в наш список *list_number_list_in_Decimal

   

#     arithmetic_mean =  sum ( list_number_list_in_Decimal ) / Decimal ( len ( number_list ) )  #  Шукаємо середнє арифметичне для нашого вхідного списку * number_list
#                                 # За допомогою вбудованої функції *sum (*list) шукаємо суму всіх елементів списку *list_number_list_in_Decimal і ділимо на кількість елементів списку (довжину списку отрману функцією *len ( number_list )  ) приведених до типу Decimal.
#                                 #  Для наших тестових значень переданих у функцію результат буде *21.714
#     #print ( arithmetic_mean )

#     return arithmetic_mean # Повертаємо розрахований результат середнього арифметичного  з функції . *arithmetic_mean = 


# number_list = [ 3, 5, 77, 23, 0.57 ] # Тестовий список

# signs_count = 6  # Тестове значення кількості  значущих цифр для даних типу  *Decimal

# print ( decimal_average ( number_list, signs_count ) ) # Принтемо результат роботи . Для наших тестових значень *21.714


# ================================ Звдання 7 / Task 7 ======================================

#  ++++++++++++++++++++ Пакет collections , Використання імених кортежів , функція *isinstance ( *обєкт, *class ) ++++++++++++++

# Використання кортежів у Python для передачі даних між обробниками — це хороша та поширена практика. 
# Але є одна незручність у кортежів, вам необхідно пам'ятати індексацію елементів у кортежі і не плутати їх порядок.
# Це не завжди зручно і для ситуацій, коли в кортежі є 2 і більше елементів, такий підхід ускладнює читабельність коду:

# person = ('Mick', 'Nitch', 35, 'Boston', '01146')
# Після створення person там, де ви його використовуєте, вам треба пам'ятати, що ім'я на першому місці,
# а вік — на третьому. Щоб не плутатися, доведеться постійно повертатися до коду, де створюється person. 
# Це незручно і спеціально для таких випадків додали іменовані кортежі:

# import collections

# Person = collections.namedtuple('Person', ['name', 'last_name', 'age', 'birth_place', 'post_index'])
# person = Person('Mick', 'Nitch', 35, 'Boston', '01146')
# person.name  # 'Mick'
# person.post_index  # '01146'
# person.age  # 35
# person[3]  # 'Boston'
# Тепер, використовуючи Person, ви можете створювати кортежі, які обов'язково повинні містити 5 елементів і у таких кортежів окрім індексів
# є атрибути. Звертатися до елементів такого кортежу можна як по індексу, так і по імені.
# При такому підході вам достатньо один раз визначити Person і більше не повертатися до нього, щоб згадати, який елемент за що відповідає.

#  # ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# У нас є іменований кортеж для зберігання котів у змінній Cat. 
# На першому місці у нас кличка котика nickname, потім його вік age та ім'я власника кота owner.

# Напишіть функцію convert_list(cats), яка працюватиме у двох режимах.

# Якщо функція convert_list приймає у параметрі cats список іменованих кортежів

# [Cat("Mick", 5, "Sara"), Cat("Barsik", 7, "Olga"), Cat("Simon", 3, "Yura")]
# То функція поверне наступний список словників:

# [
#     {"nickname": "Mick", "age": 5, "owner": "Sara"},
#     {"nickname": "Barsik", "age": 7, "owner": "Olga"},
#     {"nickname": "Simon", "age": 3, "owner": "Yura"},
# ]
# І в той же час, якщо функція convert_list приймає в параметрі cats список словників, 
# то результатом буде зворотна операція та функція поверне список іменованих кортежів.

# Для визначення типу параметра cats використовуйте функцію isinstance.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# import collections

# Cat = collections.namedtuple ("Cat", [ "nickname", "age", "owner" ] ) # Функція collections.namedtuple (*імя_класу, *list[перелік_атрибутів_класу] ,повртає іменований кортеж class <class '__main__.Cat'> наступного вигляду :
#                                                                       #  *Cat(*nickname , *age, *owner ) де *nickname , *age , *owner - це визнпчені атрибути класу які містять передані в них значення.
#                                                                       #   Звернення до елементів іменого кортежу можливе за індексом або ж за атрибутом  *Cat[0] == Cat.nickname , *Cat[1] == Cat.age і так далі. 
#                                                                       #  *Cat буде містити обєкт класу *<class '__main__.Cat'> (імений кортеж ) з заданими парметрами поврнутими з функції  *collections.namedtuple (*імя_класу ,[ *атрибут1, *атрибут2, *атрибут3, і так далі. ])
# # print ( Cat )

# def convert_dict_in_nametyple ( cats ) :   # Допоміжна функція . Отримує один аргумент типу *list , де кожен елемент є обєкт типу *dict (словник) , і повертає список з імених кортежів сформованих із цих елементів.
#                                             #  *cats : list  (елементи *cats тип *dict)

#     list_cats_typle = []  #  Список в який будемо додавати елменти типу імений кортеж класу *Cat утворений з переданого у функцію списку *cats де всі елементи  типу словник.
#                           #   Початкове значення пустий список *[]

#     for dict_cats in cats :  # Цикл в якому будемо проходитись по елементах списку *cats , формувати обєкт класу *Cat і добавляти їх в наш список *list_cats_typle
        
#         cat = Cat ( dict_cats["nickname"] , dict_cats["age"], dict_cats["owner"] )  # Формуємо обєкт класу *Cat повертаючи кожному атрибуту відповідне значення вказаного ключа з поточного словника *dict_cats
#                                                                                     # для наших тестових значень *cat == Cat(nickname='Mick', age=5, owner='Sara') на першому кроці циклу 
#                                                                                     #  *cat == Cat(nickname='Barsik', age=7, owner='Olga') - на другому кроці і так далі.

#         list_cats_typle.append( cat )  # Добавляємо в наш список поточне значення *cat
    
#     return list_cats_typle  #  Повертаємо з функції список який буде складатись з іментих кортежів утворених з елементів переданого в функцію списку * cats
#                             # Для тестового значення *list_cats_typle == [Cat(nickname='Mick', age=5, owner='Sara'), Cat(nickname='Barsik', age=7, owner='Olga'), Cat(nickname='Simon', age=3, owner='Yura')]

# def convert_nametyple_in_dict ( cats ) :  # Допоміжна функція . Отримує один аргумент типу *list , де кожен елемент є обєкт типу *імени_кортеж (в нашому випадку тип *Cat ) , і повертає список словників сформованих із цих елементів.
#                                             #  *cats : list  (елементи *cats тип *Cat )

#     list_cats_dict = []  #  Список в який будемо додавати елменти типу *dict утворений з переданого у функцію списку *cats де всі елементи  типу *Cat (імений_кортеж).
#                           #   Початкове значення пустий список *[]
 
#     for nametyple_cats in cats :  # Цикл в якому будемо проходитись по елементах списку *cats , формувати з них словник  і добавляти його в наш список *list_cats_typle

#         dict_cats_typle = {}     #   Словник в який будемо додавати пари ключ : значення отримані з поточного іменого кортежу *nametyple_cats
#                                 #   Початково значення пустий словник *{} . Цей словник оголошуємо в циклі щоб по завершеню ітерації циклу в наш список *list_cats_dict добавлялось нове значення. 
       
#         # print (nametyple_cats)
#         dict_cats_typle["nickname"] = nametyple_cats.nickname  # Стврюємо першу пару ключ: значення для нашого словника , де "nickname" буде ключем , а повернене з *nametyple_cats.nickname значення буде його значеннмя.
#                                                             #    *dict_cats_typle = {'nickname': 'Mick'}

#         dict_cats_typle["age"] = nametyple_cats.age  ## Стврюємо другу пару ключ: значення для нашого словника , де "age" буде ключем , а повернене з *nametyple_cats.age значення буде його значеннмя.
#                                                             #    *dict_cats_typle = {'nickname': 'Mick', 'age': 5}

#         dict_cats_typle["owner"] = nametyple_cats.owner  ## Стврюємо третю пару ключ: значення для нашого словника , де "owner" буде ключем , а повернене з *nametyple_cats.owner значення буде його значеннмя.
#                                                             #    *dict_cats_typle = {'nickname': 'Mick', 'age': 5, 'owner': 'Sara'}

#         list_cats_dict.append( dict_cats_typle )   # Добавляємо наш сформований поточний словник *dict_cats_typleв наш список *list_cats_dict
 
#         # print ( list_cats_dict)
    
#     return list_cats_dict  #  Повртаємо з функції наш список сформований з елементів типу словник з функції .
#                            #  Для нашого тестовго значення *list_cats_dict == [{'nickname': 'Mick', 'age': 5, 'owner': 'Sara'}, {'nickname': 'Barsik', 'age': 7, 'owner': 'Olga'}, {'nickname': 'Simon', 'age': 3, 'owner': 'Yura'}]


# def convert_list ( cats ) :  # Основна функція . Прйимає один аргумент типу список який може містити або всі елементи типу імений кортеж або всі елементи типу словник.
#                             #   Перевіряємо першй елемент списку на тип і взалежності від результату опрацьовуємо всесь список відповідною допоміжною фінкцією .

#     if isinstance ( cats[0] , dict ) :  # Умова в якій перевірємо чи налаежить перший елемент переданого у функцію списку *cats є словником (тип dict)
#                                         # Функція *isinstance ( *імя_обєкта, *вказаний_тип_для перевірки  ) повертає *True якщо обєкт відповідає вказаному типу і *False якщо ні.
#                                         #  *isinstance ( cats[0] , dict ) поверне *True якщо перший елемент - *cats[0] буде типу *dict
        
#         return convert_dict_in_nametyple ( cats )  # Якщо умова *if isinstance ( cats[0] , dict ) - виконалась . Значить переданий у функцію список *cats складається з елементів типу словник.
#                                                    # Передаємо цей аргумент в допоміжну функцію  *convert_dict_in_nametyple ( cats )  і повертаємо результат її роботи з основної функції.   
#                                                    # Поверне  *[Cat(nickname='Mick', age=5, owner='Sara'), Cat(nickname='Barsik', age=7, owner='Olga'), Cat(nickname='Simon', age=3, owner='Yura')]
#     else :

#         return convert_nametyple_in_dict ( cats )  # # Якщо умова *if isinstance ( cats[0] , dict ) - не виконалась . Значить переданий у функцію список *cats складається з елементів типу імений кортеж.
#                                                    # Передаємо цей аргумент в допоміжну функцію  *convert_nametyple_in_dict ( cats )   і повертаємо результат її роботи з основної функції
#                                                    # Поверне [{'nickname': 'Mick', 'age': 5, 'owner': 'Sara'}, {'nickname': 'Barsik', 'age': 7, 'owner': 'Olga'}, {'nickname': 'Simon', 'age': 3, 'owner': 'Yura'}]


# cats =  [ Cat("Mick", 5, "Sara"), Cat("Barsik", 7, "Olga"), Cat("Simon", 3, "Yura" ) ] # Тестове значення списку з іменованих кортежів . 

# # cats =  [
# #     {"nickname": "Mick", "age": 5, "owner": "Sara"},
# #     {"nickname": "Barsik", "age": 7, "owner": "Olga"},
# #     {"nickname": "Simon", "age": 3, "owner": "Yura"},
# #         ] # Tесотве значення списку з словників.

# print ( convert_list ( cats ) )



# ================================ Звдання 8 / Task 8 ======================================

#  ++++++++++++++++++++ Пакет collections , Використання Counter: , Функція *collections.Counter(*list) , метод *обєкт_Counter.most_common(*int)  ++++++++++++++

# Часто вам потрібно підрахувати кількість елементів у певній послідовності. Для цього зручно скористатися словником.

# student_marks = [4, 2, 4, 6, 7, 4, 2, 3, 4, 5, 6, 6, 7, 1, 1, 1, 3, 5]
# mark_counts = {}
# for mark in student_marks:
#     if mark in mark_counts:
#         mark_counts[mark] += 1
#     else:
#         mark_counts[mark] = 1
# print(mark_counts)  # {4: 4, 2: 2, 6: 3, 7: 2, 3: 2, 5: 2, 1: 3}
# Таке завдання зустрічається досить часто і, щоб не писати одні та ті ж самі 6 рядків коду постійно,
# у collections додали спеціальний словник Counter:

# import collections

# student_marks = [4, 2, 4, 6, 7, 4, 2, 3, 4, 5, 6, 6, 7, 1, 1, 1, 3, 5]
# mark_counts = collections.Counter(student_marks)
# print(mark_counts)  # Counter({4: 4, 6: 3, 1: 3, 2: 2, 7: 2, 3: 2, 5: 2})
# Але на цьому корисні властивості Counter не закінчуються. Він може вивести елементи за частотою появи:

# import collections

# student_marks = [4, 2, 4, 6, 7, 4, 2, 3, 4, 5, 6, 6, 7, 1, 1, 1, 3, 5]
# mark_counts = collections.Counter(student_marks)
# print(mark_counts.most_common(1))  # [(4, 4)]
# print(mark_counts.most_common(2))  # [(4, 4), (6, 3)]
# Ще Counter може відняти кількість елементів одного Counter від другого поелементно:

# from collections import Counter

# c = Counter(a=4, b=2, c=0, d=-2)
# d = Counter(a=1, b=2, c=3, d=4)
# c.subtract(d)
# print(c)  # Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})


#  # ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Є список IP адрес:

# IP = [
#     "85.157.172.253",
#     ...
# ]
# Реалізуйте дві функції. Перша get_count_visits_from_ip за допомогою Counter повертатиме словник, де ключ це IP,
# а значення – кількість входжень у вказаний список.

# Приклад:

# {
#     '85.157.172.253': 2,
#     ...
# }
# Друга функція get_frequent_visit_from_ip повертає кортеж з найбільш часто уживаним в списку IP і кількістю його появ в списку.

# Приклад:

# ('66.50.38.43', 4)

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# import collections  # Імпортуємо бібліотеку *collections для роботи з визначеними типами колекції з неї 

# from collections import Counter  # З бібліотеки *collections імпортуємо вбудований спеціальний словник *Counter ( повертає імений кортеж_словник Типу *Counter, де з списку(тип *list) переданого в *Counter, його формує )


# def get_count_visits_from_ip ( ips ) : # Функція яка приймає один аргумент у вигляді списку (тип *list ) і повертає імений кортеж_словник  типу *Counter({}) з параметром типу *dict(словник) де ключами будуть унікальні елементи списку а значеннями кількість їх входжень в переданий список (кількіть повторюваннь однакових елементів списку)
                                 

#     ips_counts = collections.Counter( ips )  # *collections.Counter( ips ) Формує з перданого списку *ips  імений кортеж_словник типу *Counter. 
#                                              #  Для нашого тесту *ips_counts = *Counter({'185.157.172.253': 5, '85.157.172.253': 3, '255.157.172.253': 2, '185.57.72.253': 1, '135.245.66.25': 1}
                                             

#     return ips_counts # Повертаємо з функції значення *ips_counts # ips_counts = *Counter({'185.157.172.253': 5, '85.157.172.253': 3, '255.157.172.253': 2, '185.57.72.253': 1, '135.245.66.25': 1})
    


# def get_frequent_visit_from_ip ( ips ) :  # Функція яка приймає один аргумент у вигляді списку (тип *list ) і повертає кортеж в якому буде вказаний елемент списку який трапляється найчастіше а також клькість таких входжень.
    
    
#     ips_counts = collections.Counter( ips )  # # *collections.Counter( ips ) Формує з перданого списку *ips  імений кортеж_словник типу *Counter. 
#                                              #  Для нашого тесту *ips_counts = *Counter({'185.157.172.253': 5, '85.157.172.253': 3, '255.157.172.253': 2, '185.57.72.253': 1, '135.245.66.25': 1}

#     ips_most_common = ips_counts.most_common(1)[0]  #  *ips_counts.most_common(1), з аргументом *1 , повертає з нашого обєекту *ips_counts (типу *Counter ) список який буде містити один елемент(тип *typle) в якому буде зазначено значення яке найчастіше зустрічалось в нашому вхідному списку і кліьксть таких входжень.
#                                                     # для нашого тестового *ips буде мати вигляд *[('185.157.172.253', 5)] -список з одним елементом типу кортеж.
#                                                     # *ips_counts.most_common(1)[0] - присвоюємо в *ips_most_common *0-елемент з спиcку *ips_counts.most_common(1)  , оскільки нам потрібно повернути кортеж , а не список , то в *ips_most_common присвоюємо значення *0 елемента з списку повернутого з *ips_counts.most_common(1) 

#     return ips_most_common  # # Повертаємо з функції значення *ips_most_commons # *ips_most_common = ('185.157.172.253', 5) , для нашого тесту.

# ips = IP = [
#     "85.157.172.253", "85.157.172.253","85.157.172.253",
#     "185.157.172.253","185.157.172.253","185.157.172.253","185.157.172.253","185.157.172.253",
#     "255.157.172.253","255.157.172.253",
#     "185.57.72.253", "135.245.66.25"
   
#            ]  # Тестовий словник для переврки роботи фінкції 

# print ( get_count_visits_from_ip ( ips ) )  # Принтимо результат повернутий з фінкції *get_count_visits_from_ip ( ips ) . Для нашого тестового значення буде *Counter({'185.157.172.253': 5, '85.157.172.253': 3, '255.157.172.253': 2, '185.57.72.253': 1, '135.245.66.25': 1}

# print ( get_frequent_visit_from_ip ( ips ) )  # Принтимо результат повернутий з фінкції *get_frequent_visit_from_ip ( ips ) . Для нашого тестового значення буде *('185.157.172.253', 5)
    

# ================================ Звдання 9 / Task 9 ======================================

#  ++++++++++++++++++++ Пакет collections , Використання  *deque , Стек (Stack), Списки  організованому за принципом *LIFO ++++++++++++++
# +++++ ДЛЯ КОЛЕКЦІЇ СПИСКІВ  ОРГАНІЗОВАНИХ ЗА ПРИНЦИПОМ  *FIFO , *Lifo ПРАЦЮЮТЬ ТАКІЖ МЕТОДИ ЯК І ДЛЯ ЗВИЧАЙНИХ СПИСКІВ + ДОДАТКОВІ ЯКІ ДЛЯ ЗВИЧАЙНИХ СПИСКІВ НЕ ПРАЦЮЮТЬ ++++++++
# ВЕСЬ ПЕРЕЛІК МЕТОДІВ КОЛККЦІЇ *deque ШУКАЙ В ІНТРНЕТІ.

# +++++++++ Метод колекції *deque . *імя_списку.appendleft(*елемент)-додає вказаний елемент на початок вказаного списку.
# +++++++++ Метод колекції *deque . *імя_списку.popleft()- повертає перший елемент з вказаного списку і видаляє його з цього списку.



# Списки у Python реалізовані таким чином, що вибір елемента по індексу відбувається за константний час (дуже швидко) 
# і додавання/видалення елементу в кінець списку теж відбувається дуже швидко. 
# Але ось додавання елементу у будь-яке інше місце в списку змушує Python перерахувати індекси усіх елементів списку до кінця. 
# Для великих списків це може бути дуже невигідно. Щоб швидко додавати елементи в початок списку, 
# в Python в пакеті collections є така колекція як deque:

# from collections import deque

# d = deque()
# d.append('last')
# d.appendleft('first')
# d.insert(1, 'middle')
# print(d)  # deque(['first', 'middle', 'last'])

# print(d.pop())  # 'last'
# print(d.popleft())  # 'first'
# print(d)  # deque(['middle'])
# Окрім додавання в початок за допомогою appendleft, у deque є і швидке видалення першого елементу popleft.

# Ще однією особливістю deque є можливість обмежити розмір deque:

# from collections import deque

# d = deque(maxlen=5)
# for i in range(10):
#     d.append(i)

# print(d)  # deque([5, 6, 7, 8, 9], maxlen=5)
# Як видно з прикладу, нові елементи витісняють старіші, але розмір залишається незмінним.

# В іншому deque веде себе точно як список Python.

#  # ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# LIFO (англ. last in, first out, "останнім прийшов - першим пішов") - спосіб організації даних або іншими словами Стек (Stack). 
# У структурованому лінійному списку, організованому за принципом LIFO, 
# елементи можуть додаватися та вибиратися тільки з одного кінця, що називається «вершиною списку». 
# Структура LIFO може бути проілюстрована наступним малюнком.

# lifo
# За допомогою колекції deque реалізуйте структуру даних LIFO. Створіть змінну lifo, що містить колекцію deque.
# Обмежте розмір за допомогою константи MAX_LEN. Функція push додає значення element на початок списку lifo. 
# Функція pop дістає та повертає перше значення зі списку lifo.


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from collections import deque # з бібліотеки *collections імпортуємо колекцію *deque - модуль  для роботи з списками  організованому за принципом  *FIFO , *LIFO та  іншими такого типу колекціями.

# MAX_LEN = 8 # контсатна яка містить мкасимальну кількість елементів списку класу *deque

# lifo = deque ( maxlen = MAX_LEN ) # задаємо в зміну *lifo шаблон списку класу *deque  з вказаною в *MAX_LEN кількістю елементів. 
#                          # Тобто *lifo - це список в якому може бути максимаьно 8 елементів (*MAX_LEN = 8) до яких можна застосовувати методи доступні для *deque


# def push ( element ) : # Функція  додає значення element на початок списку lifo. Приймає оди аргумент і добавляє його на початок списку .
#                     #    Повертає новий список з доданим на початку елементом.


#     lifo.appendleft ( element ) # додаємо до нашого списку *lifo (списко сформаваний і приведений до типу *deque) зліва(тобто на початок списку) переданий аргумент в функцію.
#                                 # Для нашого тестовго значення буде *lifo = *deque(['first', 1, 2, 3, 4], maxlen=8)

#     return lifo  # Повертаємо з функції значення змної *lifo . # *lifo = *deque(['first', 1, 2, 3, 4], maxlen=8)



# def pop ( lifo ) :     #  Функція pop дістає та повертає перше значення зі списку *lifo . Приймає один аргумент список колекції типу *deque() 
#                        #  Комертар : для автоперевірки має бути без аргументів  *def pop () . Для себе зробив з аргументом так практичніше в застосуаннях в подальшом.
#                       #    

#    first_element_from_lifo = lifo.popleft ()  # За допомгою методу *імя_списку_тип_deque.popleft () - колекцї *deque - повертаємот і видаляємо  з списку *lifo перший елемент.
#                                             #   Для нагого тесту *first_element_from_lifo = 'first' бо спочатку ми добавмо цей елемент в список функцією *push ( element ) а вже потім повернемо і видалемо  з списку функцією *pop ( lifo ) 
#    #print ( lifo )

#    return first_element_from_lifo  # Повертає *first_element_from_lifo .Для нагого тесту *first_element_from_lifo = 'first



# lifo = deque ( [ 1, 2 , 3, 4 ] , maxlen = MAX_LEN  ) # Формування тестовго значення списку *lifo  з колекції *deque 
#                                                     #  Функція *deque приймає один обовязковий аргумент це список і інший *maxlen - необовязковий і повертає вже список формату *deque
#                                                     # для нашого тесту буде мати вигляд *lifo = deque([ 1, 2, 3, 4], maxlen=8)

# element = "first" # Тестове значення *element який будемо добавляти на початок списку *lifo нашою фйнкцією *push ( element ) і повертати , а видялти з списку функцією *pop ( lifo ) 

# print ( push ( element ) )  # Принтемо результат роботи функції *push ( element ).*Коментра : print -робить виклик функції і відразу виводить на екран результат роботи функції.
# print ( pop ( lifo ) )      # Принтемо результат роботи функції *pop ( lifo )

# ================================ Звдання 10 / Task 10 ======================================

#  ++++++++++++++++++++ Пакет collections , Використання  *deque , Черги, Списки  організованому за принципом *FIFO ++++++++++++++
# +++++ ДЛЯ КОЛЕКЦІЇ СПИСКІВ  ОРГАНІЗОВАНИХ ЗА ПРИНЦИПОМ  *FIFO , *Lifo ПРАЦЮЮТЬ ТАКІЖ МЕТОДИ ЯК І ДЛЯ ЗВИЧАЙНИХ СПИСКІВ + ДОДАТКОВІ ЯКІ ДЛЯ ЗВИЧАЙНИХ СПИСКІВ НЕ ПРАЦЮЮТЬ ++++++++
# ВЕСЬ ПЕРЕЛІК МЕТОДІВ КОЛККЦІЇ *deque ШУКАЙ В ІНТРНЕТІ. 

# +++++++++ Метод колекції *deque . *імя_списку.appendleft(*елемент)-додає вказаний елемент на початок вказаного списку.
# +++++++++ Метод колекції *deque . *імя_списку.popleft()- повертає перший елемент з вказаного списку і видаляє його з цього списку.

#  # ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# FIFO (англ. first in, first out - "першим прийшов - першим пішов") - спосіб організації даних або іншими словами черга. 
# Цей вислів описує принцип технічної обробки черги чи обслуговування конфліктних вимог шляхом впорядкування процесу за принципом: 
# "першим прийшов - першим обслужений" (ПППО). 
# Той, хто приходить першим, той і обслуговується першим, хто прийде наступним чекає, поки обслуговування першого не буде закінчено, 
# і таке інше.

# fifo
# За допомогою колекції deque реалізуйте структуру даних FIFO. Створіть змінну fifo, що містить колекцію deque. 
# Обмежте розмір за допомогою константи MAX_LEN. Функція push додає значення element до кінця списку fifo.
# Функція pop дістає та повертає перше значення зі списку fifo.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

from collections import deque # з бібліотеки *collections імпортуємо колекцію *deque - для роботи з списками організованому за принципом  *FIFO , *LIFO та  іншими такого типу колекціями.

MAX_LEN = 8 # контсатна яка містить мкасимальну кількість елементів списку класу *deque

fifo = deque ( maxlen = MAX_LEN ) # задаємо в зміну *fifo шаблон списку класу *deque  з вказаною в *MAX_LEN кількістю елементів. 
                         # Тобто *fifo - це список в якому може бути максимаьно 8 елементів (*MAX_LEN = 8) до яких можна застосовувати методи доступні для *deque


def push ( element ) : # Функція  додає значення element в кінець списку fifo. Приймає один аргумент і добавляє його в кінець списку .
                    #    Повертає новий список з доданим на в кінці елементом.


    fifo.append ( element ) # додаємо до нашого списку *fifo (списко сформаваний і приведений до типу *deque) справа(тобто в кінець списку) переданий аргумент в функцію.
                            # Для нашого тестовго значення буде *fifo = *deque([ 1, 2, 3, 4, 'first'], maxlen=8)


    return fifo  # Повертаємо з функції значення змної *fifo . # *fifo = *deque([ 1, 2, 3, 4, 'first'], maxlen=8)



def pop ( fifo ) :     #  Функція pop дістає та повертає перше значення зі списку *fifo . Приймає один аргумент список колекції типу *deque() 
                       #  Комертар : для автоперевірки має бути без аргументів  *def pop () . Для себе зробив з аргументом так практичніше в застосуаннях в подальшом.
                       #    

   first_element_from_fifo = fifo.popleft ()  # За допомгою методу *імя_списку_тип_deque.popleft () - колекцї *deque - повертаємот і видаляємо  з списку *lifo перший елемент.
                                            #   Для нашого тесту *first_element_from_fifo = 1 , Перший елемент з списку *fifo
   #print ( lifo )

   return first_element_from_fifo  # Повертає *first_element_from_fifo .Для нашого тесту *first_element_from_fifo = 1



fifo = deque ( [ 1, 2 , 3, 4 ] , maxlen = MAX_LEN  ) # Формування тестовго значення списку *fifo  з колекції *deque 
                                                    #  Функція *deque приймає один обовязковий аргумент це список і інший *maxlen - необовязковий і повертає вже список формату *deque
                                                    # для нашого тесту буде мати вигляд *fifo = deque([ 1, 2, 3, 4], maxlen=8)

element = "first" # Тестове значення *element який будемо добавляти на початок списку *lifo нашою фйнкцією *push ( element ) і повертати , а видялти з списку функцією *pop ( lifo ) 

print ( push ( element ) )  # Принтемо результат роботи функції *push ( element ).*Коментра : print -робить виклик функції і відразу виводить на екран результат роботи функції.
                            # deque([1, 2, 3, 4, 'first'], maxlen=8)

print ( pop ( fifo ) )      # Принтемо результат роботи функції *pop ( fifo ) # deque( [ 2, 3, 4, 'first'], maxlen=8)